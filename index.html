<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPXルートビューア (ITJ) v3 - Race Mode</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f3f4f6;
        }
        #map {
            z-index: 1;
            background-color: #222;
        }
        
        /* --- 高低図エリア（左上・反透過） --- */
        #elevationChartContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            max-width: 40%; /* スマホ対応 */
            height: 80px;
            background: rgba(255, 255, 255, 0.6); /* 反透過 */
            border-radius: 8px;
            z-index: 1000;
            padding: 5px 5px 15px 5px; /* 下に少し余白 */
            backdrop-filter: blur(2px);
            pointer-events: none; /* 地図操作の邪魔にならないように */
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* --- コントロールパネル（下部・コンパクト） --- */
        .player-controls {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 95%;
            max-width: 700px;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 12px;
            border-radius: 50px; /* カプセル型 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* 凡例 */
        .legend {
            background: white;
            padding: 6px;
            border-radius: 4px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            font-size: 10px;
            line-height: 1.4;
            color: #333;
        }
        .legend i {
            width: 12px;
            height: 12px;
            float: left;
            margin-right: 4px;
            opacity: 0.8;
            border-radius: 2px;
        }
        .comment-popup .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        .comment-popup .leaflet-popup-content {
            margin: 12px;
            font-size: 13px;
            line-height: 1.5;
        }
        
        /* スライダーのカスタマイズ */
        input[type=range] {
            height: 4px;
            border-radius: 2px;
            background: #cbd5e1;
            outline: none;
            -webkit-appearance: none;
            flex-grow: 1; /* 横幅いっぱいに */
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            margin-top: -5px;
        }
        
        /* カスタムアイコン画像用スタイル */
        .custom-runner-icon {
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: white;
            object-fit: cover;
        }
        
        /* 応援メンバー用アイコンスタイル */
        .supporter-icon {
            border: 3px solid #f59e0b; /* 黄色っぽい枠 */
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: white;
            object-fit: cover;
        }

        /* 応援吹き出し */
        .cheer-popup .leaflet-popup-content-wrapper {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #ef4444;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .cheer-popup .leaflet-popup-tip {
            background: #ef4444;
        }

        /* 順位表示・タイム表示などのオーバーレイ */
        #raceStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            backdrop-filter: blur(2px);
            display: none; /* GPXロード後に表示 */
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 160px;
        }
    </style>
</head>
<body class="h-screen w-full flex flex-col overflow-hidden">

    <!-- 地図表示エリア -->
    <div id="map" class="w-full h-full absolute inset-0"></div>
    
    <!-- 順位・タイム表示 -->
    <div id="raceStatus">
        <div id="raceTimer" class="text-xl font-bold text-center mb-2 font-mono text-gray-800 bg-gray-100 rounded py-1">00:00:00</div>
        <div class="font-bold border-b border-gray-300 mb-1 pb-1 text-gray-600">Leaderboard</div>
        <div id="leaderboardContent"></div>
    </div>
    
    <!-- 高低図エリア（左上・反透過） -->
    <div id="elevationChartContainer">
        <svg id="elevationSvg" viewBox="0 0 100 100" preserveAspectRatio="none" class="overflow-visible w-full h-full">
            <defs>
                <linearGradient id="elevationGradient" x1="0" x2="0" y1="0" y2="1">
                    <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.8"/>
                    <stop offset="100%" stop-color="#3b82f6" stop-opacity="0.2"/>
                </linearGradient>
            </defs>
            <path id="elevationPath" d="" fill="url(#elevationGradient)" stroke="#2563eb" stroke-width="1.5" stroke-linejoin="round" vector-effect="non-scaling-stroke"></path>
            <!-- 自分の位置マーカー -->
            <circle id="elevationMarker" r="4" fill="#fbbf24" stroke="#fff" stroke-width="1.5" cx="0" cy="0" style="display:none;" vector-effect="non-scaling-stroke"></circle>
        </svg>
        <div id="currentEleDisplay" class="absolute top-1 right-1 text-[10px] font-bold text-blue-800 bg-white/70 px-1 rounded"></div>
    </div>

    <!-- 再生コントロールパネル（下部・横並びコンパクト） -->
    <div class="player-controls">
        <!-- 再生ボタン -->
        <button onclick="togglePlay()" id="playBtn" class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded-full shadow transition flex-shrink-0">
            <svg id="icon-play" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <svg id="icon-pause" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        </button>

        <!-- スライダー -->
        <input type="range" id="progressSlider" min="0" max="100" value="0" oninput="seekAnimation(this.value)">
        
        <!-- 距離情報 (自分の距離を表示) -->
        <div class="flex flex-col items-end text-[10px] leading-tight text-gray-600 w-16 flex-shrink-0">
            <span id="currentDistDisplay" class="font-bold text-blue-600">0.0km</span>
            <span id="totalDistDisplay" class="text-gray-400">/ 0.0km</span>
        </div>

        <!-- 速度ボタン -->
        <button onclick="changeSpeed()" id="speedBtn" class="text-[10px] font-bold text-gray-600 bg-gray-100 px-2 py-1 rounded hover:bg-gray-200 w-8 text-center flex-shrink-0 transition">x1</button>

        <!-- リセットボタン -->
        <button onclick="resetAnimation()" class="text-gray-400 hover:text-gray-600 flex-shrink-0" title="リセット">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
        </button>
    </div>
    
    <!-- 右下ボタン群 -->
    <div class="absolute bottom-24 right-4 z-[900] flex flex-col gap-3">
        <!-- アイコン読込ボタン -->
        <label class="cursor-pointer bg-white text-gray-700 p-2.5 rounded-full shadow-lg hover:bg-gray-100 transition border border-gray-200 flex items-center justify-center" title="ランナー画像を変更">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
            </svg>
            <input type="file" accept="image/*" class="hidden" onchange="handleIconSelect(event)">
        </label>

        <!-- GPX読込ボタン -->
        <label class="cursor-pointer bg-white text-gray-700 p-2.5 rounded-full shadow-lg hover:bg-gray-100 transition border border-gray-200 flex items-center justify-center" title="GPXファイルを読み込む">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
            </svg>
            <input type="file" accept=".gpx" class="hidden" onchange="handleFileSelect(event)">
        </label>

        <!-- 全体表示ボタン -->
        <button onclick="fitBoundsToTrack()" class="bg-white text-gray-700 p-2.5 rounded-full shadow-lg hover:bg-gray-100 transition border border-gray-200" title="ルート全体を表示">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
            </svg>
        </button>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <script>
        // ==========================================
        //  設定
        // ==========================================
        const GPX_FILE_URL = 'ITJ_course_2025.gpx'; 
        const REVERSE_GPX_ORDER = true; 

        // アニメーション設定
        let PLAY_SPEED = 1; 
        const SPEED_OPTIONS = [1, 3, 5, 10]; 
        const FRAME_DURATION = 3; // 1フレームあたりのシミュレーション時間(秒)

        // ランナー設定
        const RUNNER_CONFIGS = [
            { name: "けんちゃん", color: "#3b82f6", iconUrl: 'けんちゃん.png' },
            { name: "ちゃね", color: "#ef4444", iconUrl: 'ちゃね.png' }
        ];
        let runners = []; 
        let aidStationIndices = []; 
        let supporterObjs = []; 
        let elapsedTime = 0; 
        
        // 応援メンバーの移動ポイント定義
        const SUPPORT_LOCATIONS = [
            { name: "仁科展望台", lat: 34.86169, lon: 138.84546, gpxIdx: -1 },
            { name: "達磨山", lat: 34.95498, lon: 138.83926, gpxIdx: -1 },
            { name: "ゴール", lat: 34.97038, lon: 138.92860, gpxIdx: -1 }
        ];
        let currentSupportLocIndex = 0;

        // 区間ごとの速度制御用配列
        let segmentRates = [];

        // ==========================================
        //  コメントデータ
        // ==========================================
        const courseComments = [
            { lat: 34.7622, lon: 138.7757, text: "<b>\u{1F3C1} スタート：松崎港</b><br>Aブロックの先頭集団のスタートは迫力あるよー。" },
            { lat: 34.78945, lon: 138.83531, text: "<b>\u{26E9} 宝蔵院</b><br>ここまで全部のぼりー" },
            { lat: 34.7841, lon: 138.8448, text: "<b>\u{1F332} 八瀬峠</b><br>走れる林道。シングルトラック抜けた後だけど足温存で。" },
            { lat: 34.8098, lon: 138.8808, text: "<b>\u{26F0} 諸坪峠</b><br>ここもがっつり走れちゃう。まだ我慢。" },
            { lat: 34.81527, lon: 138.89888, text: "<b>\u{1F375} こがね橋エイド</b><br>桜葉もちは一人ひとつね<br>ここから二本杉までがっつり登るよー" },
            { lat: 34.82977, lon: 138.90792, text: "<b>\u{26F0} 二本杉峠</b>" },
            { lat: 34.86169, lon: 138.84546, text: "<b>\u{1F52D} 仁科展望台</b><br>かーちゃんまめちゃん応援" },
            { lat: 34.87064, lon: 138.84383, text: "<b>\u{1F35C} 仁科エイド</b><br>塩カツオうどんは食べてって！！" },
            { lat: 34.93452, lon: 138.83172, text: "<b>\u{1F372} 土肥駐車場エイド</b><br>しし汁という名の豚汁！" },
            { lat: 34.93624, lon: 138.83371, text: "ここで振り向いたら駿河湾が綺麗に見えるよ" },
            { lat: 34.95498, lon: 138.83926, text: "<b>\u{26F0} 達磨山</b><br>晴れてたら素敵な景色！！晴れてたら！！" },
            { lat: 34.96425, lon: 138.83842, text: "<b>\u{26F0} 小達磨山</b><br>これがラスボス。後は降るだけ。" },
            { lat: 34.97410, lon: 138.83662, text: "芝生ふかふかご褒美ぞーんだよ" },
            { lat: 34.97532, lon: 138.85052, text: "トイレあるよ。ブリーフィングでは閉鎖されてるって言ってたけど。" },
            { lat: 34.97501, lon: 138.85045, text: "この辺はガレガレ。捻挫注意ね" },
            { lat: 34.97087, lon: 138.86076, text: "地味に登ってる気がするけど気のせいだからね。" },
            { lat: 34.96885, lon: 138.90517, text: "ここからロード！！みんないがいとちゃんと走るよ" },
            { lat: 34.97038, lon: 138.92860, text: "<b>\u{2668} ゴール：修善寺</b>" }
        ];

        const CHECKPOINT_TARGETS = [
            { keyword: "宝蔵院", targetTime: 4500 },
            { keyword: "こがね橋", targetTime: 11400 },
            { keyword: "仁科エイド", targetTime: 21300 },
            { keyword: "土肥駐車場", targetTime: 29700 },
            { keyword: "ゴール", targetTime: 39300 }
        ];

        // ==========================================
        //  サンプルGPXデータ
        // ==========================================
        const sampleGpxLines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<gpx version="1.1" creator="Sample" xmlns="http://www.topografix.com/GPX/1/1">',
            '  <trk>',
            '    <name>ITJ Sample</name>',
            '    <trkseg>',
            // 松崎港から修善寺までの簡易ルート
            '      <trkpt lat="34.7540" lon="138.7760"><ele>5</ele></trkpt>',
            '      <trkpt lat="34.7600" lon="138.7850"><ele>50</ele></trkpt>',
            '      <trkpt lat="34.7650" lon="138.7950"><ele>100</ele></trkpt>',
            '      <trkpt lat="34.7700" lon="138.8100"><ele>400</ele></trkpt>',
            '      <trkpt lat="34.7750" lon="138.8200"><ele>550</ele></trkpt>',
            '      <trkpt lat="34.7850" lon="138.8300"><ele>700</ele></trkpt>', // 宝蔵院
            '      <trkpt lat="34.7900" lon="138.8400"><ele>600</ele></trkpt>',
            '      <trkpt lat="34.8000" lon="138.8500"><ele>500</ele></trkpt>',
            '      <trkpt lat="34.8100" lon="138.8600"><ele>700</ele></trkpt>',
            '      <trkpt lat="34.8200" lon="138.8700"><ele>900</ele></trkpt>', // 八瀬峠
            '      <trkpt lat="34.8300" lon="138.8800"><ele>880</ele></trkpt>',
            '      <trkpt lat="34.8400" lon="138.8900"><ele>850</ele></trkpt>',
            '      <trkpt lat="34.8500" lon="138.9000"><ele>920</ele></trkpt>',
            '      <trkpt lat="34.8600" lon="138.9100"><ele>1000</ele></trkpt>', // 仁科峠
            '      <trkpt lat="34.8700" lon="138.9150"><ele>980</ele></trkpt>',
            '      <trkpt lat="34.8800" lon="138.9200"><ele>950</ele></trkpt>',
            '      <trkpt lat="34.8900" lon="138.9250"><ele>880</ele></trkpt>',
            '      <trkpt lat="34.9000" lon="138.9300"><ele>800</ele></trkpt>', // 土肥峠
            '      <trkpt lat="34.9100" lon="138.9350"><ele>850</ele></trkpt>',
            '      <trkpt lat="34.9200" lon="138.9380"><ele>950</ele></trkpt>',
            '      <trkpt lat="34.9300" lon="138.9400"><ele>980</ele></trkpt>', // 達磨山
            '      <trkpt lat="34.9380" lon="138.9430"><ele>900</ele></trkpt>', // 小達磨山
            '      <trkpt lat="34.9500" lon="138.9500"><ele>600</ele></trkpt>',
            '      <trkpt lat="34.9600" lon="138.9600"><ele>300</ele></trkpt>',
            '      <trkpt lat="34.9720" lon="138.9660"><ele>50</ele></trkpt>',  // 修善寺
            '    </trkseg>',
            '  </trk>',
            '</gpx>'
        ];
        const sampleGpxData = sampleGpxLines.join("\n");

        let map;
        let currentTrackLayer = null;
        let commentLayer = null;
        let isZenMode = false;
        let gpxPoints = []; 
        let routeTotalDistance = 0;
        let minEle = 0, maxEle = 0; 
        
        let isPlaying = false;
        let animReqId = null;

        // --- グローバル関数定義 ---

        window.handleFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                processGPX(e.target.result);
            };
            reader.readAsText(file);
        };

        window.handleIconSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const newIcon = L.icon({
                    iconUrl: e.target.result,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20],
                    className: 'custom-runner-icon'
                });
                if (runners.length > 0 && runners[0].marker) {
                    runners[0].marker.setIcon(newIcon);
                }
                alert("ランナー画像を変更しました！");
            };
            reader.readAsDataURL(file);
        };

        window.toggleZenMode = function() {
            const header = document.getElementById('appHeader');
            isZenMode = !isZenMode;
            header.style.display = isZenMode ? 'none' : 'flex';
            setTimeout(() => map.invalidateSize(), 300);
        };

        window.fitBoundsToTrack = function() {
            if (currentTrackLayer) {
                const group = commentLayer ? L.featureGroup([currentTrackLayer, commentLayer]) : currentTrackLayer;
                map.fitBounds(group.getBounds(), { padding: [20, 20] });
            }
        };

        window.togglePlay = function() {
            if (gpxPoints.length === 0) return;
            isPlaying = !isPlaying;
            const playIcon = document.getElementById('icon-play');
            const pauseIcon = document.getElementById('icon-pause');

            if (isPlaying) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                if (runners.every(r => r.finished)) {
                    resetAnimation();
                    isPlaying = true;
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                }
                animLoop();
            } else {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                cancelAnimationFrame(animReqId);
            }
        };

        window.resetAnimation = function() {
            isPlaying = false;
            cancelAnimationFrame(animReqId);
            initRunners();
            elapsedTime = 0; 
            currentSupportLocIndex = 0; // 応援位置リセット
            updateSupporterPositions();
            updatePlayerUI();
            updateTimerDisplay();
            document.getElementById('icon-play').classList.remove('hidden');
            document.getElementById('icon-pause').classList.add('hidden');
            map.closePopup();
            if(gpxPoints.length > 0) {
                map.panTo([gpxPoints[0].lat, gpxPoints[0].lon]);
            }
        };

        window.seekAnimation = function(val) {
            const ratio = parseInt(val) / 100;
            const targetIdx = Math.floor((gpxPoints.length - 1) * ratio);
            
            const totalEstimatedSeconds = CHECKPOINT_TARGETS[CHECKPOINT_TARGETS.length-1].targetTime; 
            elapsedTime = totalEstimatedSeconds * ratio;

            runners.forEach(r => {
                let variation = (r.baseSpeed - 1.0) * (gpxPoints.length * 0.1); 
                let idx = targetIdx + variation;
                if (idx < 0) idx = 0;
                if (idx >= gpxPoints.length - 1) idx = gpxPoints.length - 1;
                
                r.idx = idx;
                r.finished = false;
                r.state = 'run';
                r.resumeTime = 0; 
            });
            updatePlayerUI();
            updateTimerDisplay();
        };

        window.changeSpeed = function() {
            const currentIdx = SPEED_OPTIONS.indexOf(PLAY_SPEED);
            const nextIdx = (currentIdx + 1) % SPEED_OPTIONS.length;
            PLAY_SPEED = SPEED_OPTIONS[nextIdx];
            document.getElementById('speedBtn').textContent = "x" + PLAY_SPEED;
        };

        // --- 初期化 ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadGpxFile();
            addComments();
            addSupporters(); // 初期生成
        });

        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([34.86, 138.91], 11);
            L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', {
                maxZoom: 18,
                attribution: '&copy; <a href="https://maps.gsi.go.jp/development/ichiran.html">国土地理院</a>'
            }).addTo(map);
            addLegend();

            // クリックイベントの追加：コース上の距離と座標を表示
            map.on('click', function(e) {
                if (gpxPoints.length === 0) return;

                let nearestPoint = null;
                let minDistance = Infinity;
                const clickLat = e.latlng.lat;
                const clickLng = e.latlng.lng;

                // 最寄りのコース上の点を探す
                gpxPoints.forEach(p => {
                    const dist = map.distance([clickLat, clickLng], [p.lat, p.lon]);
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearestPoint = p;
                    }
                });

                // コースから500m以内ならポップアップ表示
                if (nearestPoint && minDistance < 500) {
                    const distKm = (nearestPoint.totalDist / 1000).toFixed(1);
                    
                    L.popup()
                        .setLatLng([nearestPoint.lat, nearestPoint.lon])
                        .setContent(`
                            <div class="text-center font-sans">
                                <span class="text-blue-600 font-bold text-lg">${distKm} km地点</span>
                                <div class="text-xs text-gray-500 mt-1">
                                    Lat: ${nearestPoint.lat.toFixed(5)}<br>
                                    Lon: ${nearestPoint.lon.toFixed(5)}
                                </div>
                            </div>
                        `)
                        .openOn(map);
                }
            });
        }

        // 応援メンバー（まめちゃん・かーちゃん）の固定配置
        function addSupporters() {
            supporterObjs.forEach(s => map.removeLayer(s.marker));
            supporterObjs = [];

            // 初期位置（仁科）で生成
            const supporters = [
                { id: 0, name: "まめちゃん", file: "まめちゃん.png" }, 
                { id: 1, name: "かーちゃん", file: "かーちゃん.png" }  
            ];

            supporters.forEach(s => {
                const icon = L.icon({
                    iconUrl: s.file,
                    iconSize: [48, 48], 
                    iconAnchor: [24, 24],
                    className: 'supporter-icon' 
                });

                // 座標は updateSupporterPositions で設定するので仮
                const marker = L.marker([0, 0], { icon: icon, zIndexOffset: 500 })
                    .addTo(map)
                    .bindTooltip(s.name, { 
                        permanent: true, 
                        direction: 'bottom', 
                        offset: [0, 10],
                        className: 'font-bold text-xs bg-yellow-100 border border-yellow-300 text-yellow-800 px-1 rounded' 
                    });
                
                supporterObjs.push({ ...s, marker: marker, lat: 0, lon: 0 });
            });
            // 初期位置へ移動
            updateSupporterPositions();
        }

        // 応援メンバーの位置更新
        function updateSupporterPositions() {
            if (supporterObjs.length < 2 || SUPPORT_LOCATIONS.length === 0) return;
            
            // 現在のターゲット場所
            const loc = SUPPORT_LOCATIONS[currentSupportLocIndex];
            
            // 位置設定 (少しずらす)
            const s1 = supporterObjs[0];
            const newLat1 = loc.lat + 0.0002;
            const newLon1 = loc.lon + 0.0002;
            s1.lat = newLat1; s1.lon = newLon1;
            s1.marker.setLatLng([newLat1, newLon1]);

            const s2 = supporterObjs[1];
            const newLat2 = loc.lat - 0.0002;
            const newLon2 = loc.lon - 0.0002;
            s2.lat = newLat2; s2.lon = newLon2;
            s2.marker.setLatLng([newLat2, newLon2]);
        }

        // 応援場所の移動判定
        function checkSupportMove() {
            if (currentSupportLocIndex >= SUPPORT_LOCATIONS.length - 1) return;

            const currentLoc = SUPPORT_LOCATIONS[currentSupportLocIndex];
            if (currentLoc.gpxIdx === -1) return;

            // 全ランナーが現在の応援ポイントを通過したか (少しマージン +50)
            const allPassed = runners.every(r => r.idx > currentLoc.gpxIdx + 50);

            if (allPassed) {
                currentSupportLocIndex++;
                updateSupporterPositions();
                // 新しい場所で応援できるようにフラグクリア
                runners.forEach(r => r.cheeredSupporters.clear());
            }
        }

        function addComments() {
            if (commentLayer) map.removeLayer(commentLayer);
            commentLayer = L.featureGroup();
            courseComments.forEach(comment => {
                const marker = L.marker([comment.lat, comment.lon])
                    .bindPopup(comment.text, { className: 'comment-popup', closeButton: false, autoClose: false });
                marker.addTo(commentLayer);
            });
            commentLayer.addTo(map);
        }

        function loadGpxFile() {
            fetch(GPX_FILE_URL)
                .then(r => r.ok ? r.text() : Promise.reject(r.status))
                .then(text => processGPX(text))
                .catch(() => {
                    console.warn("外部GPX読み込み失敗。サンプルを使用。");
                    processGPX(sampleGpxData);
                });
        }

        function identifyAidStations() {
            aidStationIndices = [];
            courseComments.forEach(c => {
                if (c.text.includes("エイド") || c.text.includes("休憩") || c.text.includes("駐車場")) {
                    let minDist = Infinity;
                    let closestIdx = -1;
                    gpxPoints.forEach((p, i) => {
                        const d = map.distance([c.lat, c.lon], [p.lat, p.lon]);
                        if (d < minDist) {
                            minDist = d;
                            closestIdx = i;
                        }
                    });
                    if (closestIdx !== -1 && minDist < 200) { 
                        aidStationIndices.push(closestIdx);
                    }
                }
            });
        }

        function calculateSegmentRates() {
            segmentRates = [];
            let currentIdx = 0;
            let currentTime = 0;

            CHECKPOINT_TARGETS.forEach(target => {
                let targetIdx = -1;
                const comment = courseComments.find(c => c.text.includes(target.keyword));
                if (comment) {
                    let minDist = Infinity;
                    gpxPoints.forEach((p, i) => {
                        const d = map.distance([comment.lat, comment.lon], [p.lat, p.lon]);
                        if (d < minDist) {
                            minDist = d;
                            targetIdx = i;
                        }
                    });
                } else {
                    if (target.keyword === "ゴール") targetIdx = gpxPoints.length - 1;
                }

                if (targetIdx !== -1 && targetIdx > currentIdx) {
                    const distPoints = targetIdx - currentIdx; 
                    const durationSeconds = target.targetTime - currentTime; 
                    
                    if (durationSeconds > 0) {
                        const pointsPerFrame = distPoints / (durationSeconds / FRAME_DURATION);
                        segmentRates.push({
                            endIdx: targetIdx,
                            rate: pointsPerFrame
                        });
                    }
                    currentIdx = targetIdx;
                    currentTime = target.targetTime;
                }
            });
            
            if (currentIdx < gpxPoints.length - 1) {
                segmentRates.push({
                    endIdx: gpxPoints.length - 1,
                    rate: 1.0 
                });
            }
        }

        function initRunners() {
            runners.forEach(r => { if(r.marker) map.removeLayer(r.marker); });
            runners = [];
            const startPt = gpxPoints[0] || {lat:0, lon:0};

            RUNNER_CONFIGS.forEach((config, i) => {
                // スピード: 0.85 ~ 1.15
                const randomSpeed = 0.85 + Math.random() * 0.3; 
                const randomStamina = 0.8 + Math.random() * 0.4;

                const icon = L.icon({
                    iconUrl: config.iconUrl,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20],
                    className: 'custom-runner-icon'
                });

                const marker = L.marker([startPt.lat, startPt.lon], {
                    icon: icon,
                    zIndexOffset: 2000 - (i * 100) 
                }).addTo(map);
                
                marker.bindTooltip(config.name, { 
                    permanent: false, 
                    direction: 'top',
                    className: 'text-xs font-bold'
                });

                runners.push({
                    id: i,
                    name: config.name,
                    color: config.color,
                    baseSpeed: randomSpeed, 
                    stamina: randomStamina, 
                    idx: 0, 
                    state: 'run', 
                    resumeTime: 0, 
                    restedStations: new Set(), 
                    cheeredSupporters: new Set(), 
                    finished: false,
                    finishTime: null, 
                    marker: marker
                });
            });
            
            document.getElementById('raceStatus').style.display = 'block';
            updateLeaderboard();
        }

        function processGPX(xmlString) {
            try {
                if (currentTrackLayer) {
                    map.removeLayer(currentTrackLayer);
                    currentTrackLayer = null;
                }

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                const trkpts = xmlDoc.getElementsByTagName("trkpt");

                if (trkpts.length === 0) return alert("トラックデータがありません");

                let rawPoints = [];
                for (let i = 0; i < trkpts.length; i++) {
                    const lat = parseFloat(trkpts[i].getAttribute("lat"));
                    const lon = parseFloat(trkpts[i].getAttribute("lon"));
                    const ele = parseFloat(trkpts[i].getElementsByTagName("ele")[0]?.textContent || 0);
                    rawPoints.push({ lat, lon, ele });
                }

                if (REVERSE_GPX_ORDER) rawPoints.reverse();

                // === 補間処理 (約10mごと) ===
                const interpolatedPoints = [];
                const INTERVAL = 10; 

                if (rawPoints.length > 0) {
                    interpolatedPoints.push(rawPoints[0]);
                    for (let i = 0; i < rawPoints.length - 1; i++) {
                        const p1 = rawPoints[i];
                        const p2 = rawPoints[i+1];
                        const dist = map.distance([p1.lat, p1.lon], [p2.lat, p2.lon]);
                        if (dist > INTERVAL) {
                            const steps = Math.floor(dist / INTERVAL);
                            for (let j = 1; j <= steps; j++) {
                                const ratio = j / (steps + 1);
                                const lat = p1.lat + (p2.lat - p1.lat) * ratio;
                                const lon = p1.lon + (p2.lon - p1.lon) * ratio;
                                const ele = p1.ele + (p2.ele - p1.ele) * ratio;
                                interpolatedPoints.push({ lat, lon, ele });
                            }
                        }
                        interpolatedPoints.push(p2);
                    }
                }

                const points = [];
                let totalDist = 0;
                minEle = Infinity;
                maxEle = -Infinity;

                for (let i = 0; i < interpolatedPoints.length; i++) {
                    const p = interpolatedPoints[i];
                    if (i > 0) {
                        const prev = interpolatedPoints[i-1];
                        const dist = map.distance([prev.lat, prev.lon], [p.lat, p.lon]);
                        totalDist += dist;
                    }
                    if (p.ele < minEle) minEle = p.ele;
                    if (p.ele > maxEle) maxEle = p.ele;
                    points.push({ lat: p.lat, lon: p.lon, ele: p.ele, totalDist: totalDist });
                }

                gpxPoints = points;
                routeTotalDistance = totalDist;

                document.getElementById('totalDistDisplay').textContent = "/ " + (totalDist / 1000).toFixed(1) + "km";
                document.getElementById('progressSlider').max = 100; 

                drawColoredTrack(points);
                drawElevationChart(points);
                
                // 時間経過のスケール計算
                if (routeTotalDistance > 0) {
                    const targetSeconds = 38400; // 平均ターゲット
                    const totalFrames = routeTotalDistance / 10; // 10m刻み
                    timeStep = targetSeconds / totalFrames;
                }

                // 応援ポイントのGPXインデックスを特定
                SUPPORT_LOCATIONS.forEach(loc => {
                    let minDist = Infinity;
                    let closestIdx = -1;
                    gpxPoints.forEach((p, i) => {
                        const d = map.distance([loc.lat, loc.lon], [p.lat, p.lon]);
                        if (d < minDist) {
                            minDist = d;
                            closestIdx = i;
                        }
                    });
                    loc.gpxIdx = closestIdx;
                });

                identifyAidStations();
                calculateSegmentRates(); 
                initRunners();
                addComments(); 

            } catch (err) {
                console.error("GPX解析エラー:", err);
                alert("GPXファイルの読み込みに失敗しました。");
            }
        }

        function drawElevationChart(points) {
            const path = document.getElementById('elevationPath');
            if (points.length < 2) return;
            let d = `M 0,100 `;
            const eleRange = maxEle - minEle;
            const eleBottom = minEle - eleRange * 0.1;
            const eleHeight = eleRange * 1.2; 
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const x = (p.totalDist / routeTotalDistance) * 100;
                const y = 100 - ((p.ele - eleBottom) / eleHeight) * 100;
                d += `L ${x.toFixed(2)},${y.toFixed(2)} `;
            }
            d += `L 100,100 Z`;
            path.setAttribute('d', d);
        }

        function drawColoredTrack(points) {
            if (currentTrackLayer) map.removeLayer(currentTrackLayer);
            currentTrackLayer = L.featureGroup();
            const canvasRenderer = L.canvas({ padding: 0.5 });
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                const eleDiff = p2.ele - p1.ele;
                const dist = p2.totalDist - p1.totalDist;
                let color = "#66bd63";
                if (dist > 0) {
                    const gradient = (eleDiff / dist) * 100;
                    if (gradient >= 5) color = "#d73027";
                    else if (gradient >= 1) color = "#fc8d59";
                    else if (gradient > -1) color = "#66bd63";
                    else if (gradient > -5) color = "#4575b4";
                    else color = "#313695";
                }
                L.polyline([[p1.lat, p1.lon], [p2.lat, p2.lon]], {
                    color: color, weight: 5, opacity: 0.8, renderer: canvasRenderer
                }).addTo(currentTrackLayer);
            }
            currentTrackLayer.addTo(map);
            map.fitBounds(currentTrackLayer.getBounds(), { padding: [20, 20] });
        }

        function addLegend() {
            const legend = L.control({position: 'topright'});
            legend.onAdd = function () {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = `
                    <div style="font-weight:bold; margin-bottom:4px; border-bottom:1px solid #ddd;">勾配</div>
                    <div><i style="background: #d73027"></i> 急な上り</div>
                    <div><i style="background: #fc8d59"></i> 上り</div>
                    <div><i style="background: #66bd63"></i> 平坦</div>
                    <div><i style="background: #4575b4"></i> 下り</div>
                    <div><i style="background: #313695"></i> 急な下り</div>
                `;
                return div;
            };
            legend.addTo(map);
        }

        function animLoop() {
            if (!isPlaying) return;
            
            let anyoneRunning = false;
            
            elapsedTime += FRAME_DURATION * PLAY_SPEED; 
            updateTimerDisplay();

            // 応援移動チェック
            checkSupportMove();

            runners.forEach(r => {
                if (r.finished) return;
                anyoneRunning = true;

                // 休憩処理: 時間ベースに変更
                if (r.state === 'stop') {
                    if (elapsedTime >= r.resumeTime) {
                        r.state = 'run';
                        r.idx += 1.0; 
                    }
                    return; 
                }

                aidStationIndices.forEach((aidIdx, aidId) => {
                    if (Math.abs(r.idx - aidIdx) < 5 && !r.restedStations.has(aidId)) {
                        if (Math.random() < 0.9) {
                            r.state = 'stop';
                            // 休憩時間: 1分(60秒) 0 10分(600秒)
                            const restDuration = 60 + Math.random() * 540; 
                            r.resumeTime = elapsedTime + restDuration;
                            r.restedStations.add(aidId);
                        } else {
                            r.restedStations.add(aidId);
                        }
                    }
                });

                if (r.state === 'stop') return;

                let segmentRate = 1.0;
                for (let seg of segmentRates) {
                    if (r.idx < seg.endIdx) {
                        segmentRate = seg.rate;
                        break;
                    }
                }

                const progress = r.idx / (gpxPoints.length - 1);
                const staminaFactor = 1.0 + (r.stamina - 1.0) * progress; 
                const noise = 0.9 + Math.random() * 0.2; 
                
                const moveAmount = segmentRate * r.baseSpeed * PLAY_SPEED * noise * Math.max(0.5, staminaFactor);
                
                r.idx += moveAmount;

                if (r.idx >= gpxPoints.length - 1) {
                    r.idx = gpxPoints.length - 1;
                    if (!r.finished) {
                        r.finished = true;
                        r.finishTime = document.getElementById('raceTimer').textContent;
                    }
                }
            });

            if (!anyoneRunning) {
                isPlaying = false;
                updatePlayerUI();
                updateLeaderboard(); 
                return;
            }

            updatePlayerUI();
            checkAndShowComment();
            checkSupporterCheer();
            updateLeaderboard();

            animReqId = requestAnimationFrame(animLoop);
        }

        function checkSupporterCheer() {
            runners.forEach(r => {
                if (r.finished || r.state === 'stop') return;
                const p = gpxPoints[Math.floor(r.idx)];
                if (!p) return;

                supporterObjs.forEach(s => {
                    if (r.cheeredSupporters.has(s.id)) return;
                    const dist = map.distance([p.lat, p.lon], [s.lat, s.lon]);
                    if (dist < 80) {
                        r.cheeredSupporters.add(s.id);
                        
                        let msg = "がんばれー！！";
                        if (currentSupportLocIndex === SUPPORT_LOCATIONS.length - 1) {
                            msg = "おつかれさまー！！";
                        }

                        const popup = L.popup({
                            offset: [0, -30], 
                            autoClose: false, 
                            closeOnClick: false,
                            closeButton: false,
                            className: 'cheer-popup font-bold text-red-600'
                        })
                        .setLatLng([s.lat, s.lon])
                        .setContent(`<div>${msg}<br><span class="text-xs text-gray-500 font-normal">to ${r.name}</span></div>`);
                        map.addLayer(popup);
                        setTimeout(() => { map.removeLayer(popup); }, 1500);
                    }
                });
            });
        }

        function updatePlayerUI() {
            runners.forEach(r => {
                const i = Math.floor(r.idx);
                const p = gpxPoints[i];
                if (p) {
                    r.marker.setLatLng([p.lat, p.lon]);
                    const opacity = r.state === 'stop' ? 0.5 : 1.0;
                    if (typeof r.marker.setOpacity === 'function') {
                        r.marker.setOpacity(opacity);
                    }
                }
            });

            const me = runners[0];
            const myP = gpxPoints[Math.floor(me.idx)];
            if (myP) {
                map.panTo([myP.lat, myP.lon], { animate: false }); 
                const percent = (me.idx / (gpxPoints.length - 1)) * 100;
                document.getElementById('progressSlider').value = percent;
                document.getElementById('currentDistDisplay').textContent = (myP.totalDist / 1000).toFixed(1) + "km";

                const chartMarker = document.getElementById('elevationMarker');
                if (chartMarker) {
                    const eleRange = maxEle - minEle;
                    const eleBottom = minEle - eleRange * 0.1;
                    const eleHeight = eleRange * 1.2;
                    const x = (myP.totalDist / routeTotalDistance) * 100;
                    const y = 100 - ((myP.ele - eleBottom) / eleHeight) * 100;
                    chartMarker.style.display = 'block';
                    chartMarker.setAttribute('cx', x + '%');
                    chartMarker.setAttribute('cy', y + '%');
                    document.getElementById('currentEleDisplay').textContent = Math.round(myP.ele) + "m";
                }
            }
        }

        function updateTimerDisplay() {
            const hours = Math.floor(elapsedTime / 3600);
            const minutes = Math.floor((elapsedTime % 3600) / 60);
            const seconds = Math.floor(elapsedTime % 60);
            const timeStr = 
                String(hours).padStart(2, '0') + ':' + 
                String(minutes).padStart(2, '0') + ':' + 
                String(seconds).padStart(2, '0');
            document.getElementById('raceTimer').textContent = timeStr;
        }

        function updateLeaderboard() {
            const sortedRunners = [...runners].sort((a, b) => {
                if (a.finished && b.finished) {
                    return a.finishTime.localeCompare(b.finishTime);
                }
                if (a.finished) return -1; 
                if (b.finished) return 1;
                return b.idx - a.idx;
            });
            
            let html = '<div class="flex flex-col gap-1">';
            sortedRunners.forEach((r, i) => {
                let statusText = "";
                if (r.finished) {
                    statusText = `<span class="text-red-600 font-bold">Goal! ${r.finishTime}</span>`;
                } else {
                    const distKm = gpxPoints[Math.floor(r.idx)] ? (gpxPoints[Math.floor(r.idx)].totalDist / 1000).toFixed(1) : "0.0";
                    const stateIcon = r.state === 'stop' ? "&" : "<ﾘﾃﾟ";
                    statusText = `${distKm}km ${stateIcon}`;
                }
                const style = r.id === 0 ? "font-weight:bold; color:#2563eb;" : "color:#444;";
                html += `
                <div style="${style} display:flex; justify-content:space-between; align-items:center;">
                    <span>${i+1}. <span style="color:${r.color}">●</span> ${r.name}</span>
                    <span style="font-size:10px; margin-left:8px;">${statusText}</span>
                </div>`;
            });
            html += '</div>';
            document.getElementById('leaderboardContent').innerHTML = html;
        }

        function checkAndShowComment() {
            const me = runners[0];
            const currentP = gpxPoints[Math.floor(me.idx)];
            if (!currentP) return;
            courseComments.forEach((c) => {
                const dist = map.distance([currentP.lat, currentP.lon], [c.lat, c.lon]);
                if (dist < 150) {
                    L.popup({ autoClose: true, closeOnClick: false, offset: [0, -10] })
                        .setLatLng([c.lat, c.lon]).setContent(c.text).openOn(map);
                }
            });
        }
    </script>
</body>
</html>