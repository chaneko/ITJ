<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPXãƒ«ãƒ¼ãƒˆãƒ“ãƒ¥ãƒ¼ã‚¢ (ITJ) v3 - Race Mode</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f3f4f6;
        }
        #map {
            z-index: 1;
            background-color: #222;
        }
        
        /* --- é«˜ä½å›³ã‚¨ãƒªã‚¢ï¼ˆå·¦ä¸Šãƒ»åé€éï¼‰ --- */
        #elevationChartContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            max-width: 40%; /* ã‚¹ãƒãƒ›å¯¾å¿œ */
            height: 80px;
            background: rgba(255, 255, 255, 0.6); /* åé€é */
            border-radius: 8px;
            z-index: 1000;
            padding: 5px 5px 15px 5px; /* ä¸‹ã«å°‘ã—ä½™ç™½ */
            backdrop-filter: blur(2px);
            pointer-events: none; /* åœ°å›³æ“ä½œã®é‚ªé­”ã«ãªã‚‰ãªã„ã‚ˆã†ã« */
            border: 1px solid rgba(255,255,255,0.3);
        }

        /* --- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ï¼ˆä¸‹éƒ¨ãƒ»ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆï¼‰ --- */
        /* AIå®Ÿæ³ãƒãƒ¼ã®ãŸã‚ã«å°‘ã—ä¸Šã«é…ç½® */
        .player-controls {
            position: absolute;
            bottom: 50px; /* 24px -> 50px */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: auto; 
            min-width: 300px;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 16px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            transition: bottom 0.3s;
        }

        /* å‡¡ä¾‹ */
        .legend {
            background: white;
            padding: 6px;
            border-radius: 4px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            font-size: 10px;
            line-height: 1.4;
            color: #333;
        }
        .legend i {
            width: 12px;
            height: 12px;
            float: left;
            margin-right: 4px;
            opacity: 0.8;
            border-radius: 2px;
        }
        .comment-popup .leaflet-popup-content-wrapper {
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        .comment-popup .leaflet-popup-content {
            margin: 12px;
            font-size: 13px;
            line-height: 1.5;
        }
        
        /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
        input[type=range] {
            height: 4px;
            border-radius: 2px;
            background: #cbd5e1;
            outline: none;
            -webkit-appearance: none;
            flex-grow: 1; /* æ¨ªå¹…ã„ã£ã±ã„ã« */
            cursor: pointer;
            width: 120px; /* å¹…ã‚’å›ºå®šã—ã¦ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã« */
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            margin-top: -5px;
        }
        
        /* ã‚«ã‚¹ã‚¿ãƒ ã‚¢ã‚¤ã‚³ãƒ³ç”»åƒç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .custom-runner-icon {
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            background: white;
            object-fit: cover;
        }
        
        /* å¿œæ´å¹ãå‡ºã— */
        .cheer-popup .leaflet-popup-content-wrapper {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #ef4444;
            border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .cheer-popup .leaflet-popup-tip {
            background: #ef4444;
        }

        /* é †ä½è¡¨ç¤ºãƒ»ã‚¿ã‚¤ãƒ è¡¨ç¤ºãªã©ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #raceStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            backdrop-filter: blur(2px);
            display: none; /* GPXãƒ­ãƒ¼ãƒ‰å¾Œã«è¡¨ç¤º */
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 160px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* AIå®Ÿæ³ãƒãƒ¼ï¼ˆãƒ‹ãƒ¥ãƒ¼ã‚¹ãƒ†ã‚£ãƒƒã‚«ãƒ¼é¢¨ï¼‰ */
        #aiCommentaryBox {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(20, 20, 30, 0.9);
            color: #fbbf24; /* Amber-400 */
            z-index: 2000;
            display: flex; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¡¨ç¤º */
            align-items: center;
            overflow: hidden;
            white-space: nowrap;
            border-top: 1px solid rgba(255,255,255,0.2);
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        }
        
        .ai-label {
            background: #7c3aed; /* Violet-600 */
            color: white;
            padding: 0 12px;
            height: 100%;
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 12px;
            z-index: 10;
            box-shadow: 2px 0 5px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }

        #aiCommentaryText {
            padding-left: 100%;
            display: inline-block;
            animation: marquee 25s linear infinite;
            color: #f3f4f6;
            font-weight: 500;
        }

        @keyframes marquee {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 3000; /* AIå®Ÿæ³ãƒãƒ¼ã‚ˆã‚Šä¸Šã« */
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 12px;
            width: 90%;
            max-width: 320px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        /* ãƒªã‚¶ãƒ«ãƒˆç”»é¢å°‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        #resultModal .modal-content {
            max-width: 480px;
            background: linear-gradient(to bottom right, #ffffff, #f0f9ff);
        }
        .podium-container {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            gap: 8px;
            margin: 20px 0;
            height: 160px;
        }
        .podium-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        .podium-rank {
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 4px;
            text-shadow: 1px 1px 0 #fff;
        }
        .podium-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 10;
            background: white;
            object-fit: cover;
            margin-bottom: -15px; /* å°åº§ã«ã‚ã‚Šè¾¼ã¾ã›ã‚‹ */
        }
        .podium-base {
            width: 70px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 8px;
            color: white;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        /* 1ä½ */
        .rank-1 .podium-icon { width: 80px; height: 80px; border-color: #fbbf24; }
        .rank-1 .podium-base { height: 100px; background: linear-gradient(to bottom, #fbbf24, #d97706); }
        .rank-1 .podium-rank { color: #d97706; font-size: 1.5em; }
        /* 2ä½ */
        .rank-2 .podium-base { height: 70px; background: linear-gradient(to bottom, #9ca3af, #4b5563); }
        .rank-2 .podium-rank { color: #4b5563; }
        /* 3ä½ */
        .rank-3 .podium-base { height: 50px; background: linear-gradient(to bottom, #fdba74, #c2410c); }
        .rank-3 .podium-rank { color: #c2410c; }

        .result-list {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid #eee;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #f3f4f6;
        }
    </style>
</head>
<body class="h-screen w-full flex flex-col overflow-hidden">

    <!-- åœ°å›³è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
    <div id="map" class="w-full h-full absolute inset-0"></div>
    
    <!-- é †ä½ãƒ»ã‚¿ã‚¤ãƒ è¡¨ç¤º -->
    <div id="raceStatus">
        <div id="raceTimer" class="text-xl font-bold text-center mb-2 font-mono text-gray-800 bg-gray-100 rounded py-1">00:00:00</div>
        <div class="font-bold border-b border-gray-300 mb-1 pb-1 text-gray-600">Leaderboard</div>
        <div id="leaderboardContent"></div>
    </div>

    <!-- AIå®Ÿæ³ãƒãƒ¼ (ä¸‹éƒ¨å›ºå®š) -->
    <div id="aiCommentaryBox">
        <div class="ai-label">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path d="M2 5a2 2 0 012-2h7a2 2 0 012 2v4a2 2 0 01-2 2H9l-3 3v-3H4a2 2 0 01-2-2V5z" />
                <path d="M15 7v2a4 4 0 01-4 4H9.828l-1.766 1.767c.28.149.599.233.938.233h2l3 3v-3h2a2 2 0 002-2V9a2 2 0 00-2-2h-1z" />
            </svg>
            AIå®Ÿæ³ LIVE
        </div>
        <div id="aiCommentaryText">
            ãƒ¬ãƒ¼ã‚¹é–‹å§‹æº–å‚™ä¸­... AIå®Ÿæ³ãŒã“ã“ã«æµã‚Œã¾ã™...
        </div>
    </div>
    
    <!-- é«˜ä½å›³ã‚¨ãƒªã‚¢ï¼ˆå·¦ä¸Šãƒ»åé€éï¼‰ -->
    <div id="elevationChartContainer">
        <svg id="elevationSvg" viewBox="0 0 100 100" preserveAspectRatio="none" class="overflow-visible w-full h-full">
            <defs>
                <linearGradient id="elevationGradient" x1="0" x2="0" y1="0" y2="1">
                    <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.8"/>
                    <stop offset="100%" stop-color="#3b82f6" stop-opacity="0.2"/>
                </linearGradient>
            </defs>
            <path id="elevationPath" d="" fill="url(#elevationGradient)" stroke="#2563eb" stroke-width="1.5" stroke-linejoin="round" vector-effect="non-scaling-stroke"></path>
            <!-- è‡ªåˆ†ã®ä½ç½®ãƒãƒ¼ã‚«ãƒ¼ -->
            <circle id="elevationMarker" r="4" fill="#fbbf24" stroke="#fff" stroke-width="1.5" cx="0" cy="0" style="display:none;" vector-effect="non-scaling-stroke"></circle>
        </svg>
        <div id="currentEleDisplay" class="absolute top-1 right-1 text-[10px] font-bold text-blue-800 bg-white/70 px-1 rounded"></div>
    </div>

    <!-- å†ç”Ÿã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ï¼ˆä¸‹éƒ¨ãƒ»ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆï¼‰ -->
    <div class="player-controls">
        <!-- å†ç”Ÿãƒœã‚¿ãƒ³ -->
        <button onclick="togglePlay()" id="playBtn" class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded-full shadow transition flex-shrink-0">
            <svg id="icon-play" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <svg id="icon-pause" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        </button>

        <!-- ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ -->
        <input type="range" id="progressSlider" min="0" max="100" value="0" oninput="seekAnimation(this.value)">
        
        <!-- è·é›¢æƒ…å ± (è‡ªåˆ†ã®è·é›¢ã‚’è¡¨ç¤º) -->
        <div class="flex flex-col items-end text-[10px] leading-tight text-gray-600 w-16 flex-shrink-0">
            <span id="currentDistDisplay" class="font-bold text-blue-600">0.0km</span>
            <span id="totalDistDisplay" class="text-gray-400">/ 0.0km</span>
        </div>

        <!-- é€Ÿåº¦ãƒœã‚¿ãƒ³ -->
        <button onclick="changeSpeed()" id="speedBtn" class="text-[10px] font-bold text-gray-600 bg-gray-100 px-2 py-1 rounded hover:bg-gray-200 w-8 text-center flex-shrink-0 transition">x1</button>

        <!-- ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ -->
        <button onclick="resetAnimation()" class="text-gray-400 hover:text-gray-600 flex-shrink-0" title="ãƒªã‚»ãƒƒãƒˆ">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
        </button>
    </div>
    
    <!-- å³ä¸‹ãƒœã‚¿ãƒ³ç¾¤ï¼ˆä¸‹æƒãˆãƒ»æ¨ªä¸¦ã³ï¼‰ -->
    <div class="absolute bottom-12 right-4 z-[900] flex flex-row gap-3">
        <!-- AIå®Ÿæ³ON/OFFãƒœã‚¿ãƒ³ -->
        <button onclick="toggleAiCommentary()" id="btnAiToggle" class="bg-purple-600 text-white p-2.5 rounded-full shadow-lg hover:bg-purple-700 transition border border-purple-800 flex items-center justify-center font-bold text-xs" title="AIå®Ÿæ³ ON/OFF">
            AI ON
        </button>

        <!-- å¿œæ´ãƒœã‚¿ãƒ³ -->
        <button onclick="openCheerModal()" class="bg-white text-yellow-600 p-2.5 rounded-full shadow-lg hover:bg-gray-100 transition border border-gray-200 flex items-center justify-center" title="å¿œæ´ã—ã¦ãƒšãƒ¼ã‚¹ã‚¢ãƒƒãƒ—ï¼">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z" />
            </svg>
        </button>

        <!-- GPXèª­è¾¼ãƒœã‚¿ãƒ³ -->
        <label class="cursor-pointer bg-white text-gray-700 p-2.5 rounded-full shadow-lg hover:bg-gray-100 transition border border-gray-200 flex items-center justify-center" title="GPXãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
            </svg>
            <input type="file" accept=".gpx" class="hidden" onchange="handleFileSelect(event)">
        </label>

        <!-- å…¨ä½“è¡¨ç¤ºãƒœã‚¿ãƒ³ -->
        <button onclick="fitBoundsToTrack()" class="bg-white text-gray-700 p-2.5 rounded-full shadow-lg hover:bg-gray-100 transition border border-gray-200" title="ãƒ«ãƒ¼ãƒˆå…¨ä½“ã‚’è¡¨ç¤º">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
            </svg>
        </button>
    </div>

    <!-- å¿œæ´ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="cheerModal" class="modal-overlay">
        <div class="modal-content">
            <h3 class="text-lg font-bold mb-4 text-gray-800">ğŸ“£ èª°ã‚’å¿œæ´ã™ã‚‹ï¼Ÿ</h3>
            <div id="cheerRunnerList" class="flex flex-col gap-3">
                <!-- JSã§ç”Ÿæˆ -->
            </div>
            <button onclick="closeCheerModal()" class="mt-4 text-sm text-gray-500 hover:text-gray-800 underline">é–‰ã˜ã‚‹</button>
        </div>
    </div>

    <!-- ãƒªã‚¶ãƒ«ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="resultModal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-2 text-gray-800">ğŸ† Race Results ğŸ†</h2>
            <div class="text-sm text-gray-500 mb-4">å…¨å“¡ã‚´ãƒ¼ãƒ«ã—ã¾ã—ãŸï¼ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼</div>
            
            <!-- è¡¨å½°å°ã‚¨ãƒªã‚¢ -->
            <div id="podiumArea" class="podium-container">
                <!-- JSã§ç”Ÿæˆ -->
            </div>

            <!-- å…¨å“¡ã®çµæœãƒªã‚¹ãƒˆ -->
            <div id="resultListArea" class="result-list">
                <!-- JSã§ç”Ÿæˆ -->
            </div>

            <div class="mt-5 flex justify-center gap-4">
                <button onclick="closeResultModal()" class="bg-gray-200 text-gray-700 py-2 px-4 rounded hover:bg-gray-300 transition">é–‰ã˜ã‚‹</button>
                <button onclick="resetAnimation(); closeResultModal();" class="bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700 transition">ã‚‚ã†ä¸€åº¦èµ°ã‚‹</button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <script>
        // ==========================================
        //  è¨­å®š
        // ==========================================
        const GPX_FILE_URL = 'ITJ_course_2025.gpx'; 
        const REVERSE_GPX_ORDER = true; 
        const apiKey = ""; // Gemini API Key

        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
        let PLAY_SPEED = 1; 
        const SPEED_OPTIONS = [1, 3, 5, 10]; 
        const FRAME_DURATION = 3; // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“(ç§’)

        // ãƒ©ãƒ³ãƒŠãƒ¼è¨­å®š (ãƒ•ã‚¡ã‚¤ãƒ«åã¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æƒ…å ±ã‚’å®šç¾©)
        const RUNNER_CONFIGS = [
            { name: "ã‘ã‚“ã¡ã‚ƒã‚“", color: "#3b82f6", fileName: "ã‘ã‚“ã¡ã‚ƒã‚“.png", fallbackText: "Ken" },
            { name: "ã‚Šã‚‡ã†ã“ã•ã‚“", color: "#ec4899", fileName: "ã‚Šã‚‡ã†ã“ã•ã‚“.png", fallbackText: "Ryo" },
            { name: "ãƒã‚¿ã‚³ã•ã‚“", color: "#f97316", fileName: "ãƒã‚¿ã‚³ã•ã‚“.png", fallbackText: "Bat" },
            { name: "ã¶ãƒ¼ã¡ã‚“", color: "#22c55e", fileName: "ã¶ãƒ¼ã¡ã‚“.png", fallbackText: "Boo" },
            { name: "ã‚„ã£ã¡", color: "#a855f7", fileName: "ã‚„ã£ã¡.png", fallbackText: "Yat" },
            { name: "ã˜ã‚…ã‚“", color: "#06b6d4", fileName: "ã˜ã‚…ã‚“.png", fallbackText: "Jun" },
            { name: "ã¡ã‚ƒã­", color: "#eab308", fileName: "ã¡ã‚ƒã­.png", fallbackText: "Cha" }
        ];
        let runners = []; 
        let aidStationIndices = []; 
        let elapsedTime = 0; 
        
        // AIå®Ÿæ³é–¢é€£
        let isAiCommentaryOn = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆON
        let aiInterval = null;
        let raceEvents = []; // AIå®Ÿæ³ã«é€ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°
        let lastRankMap = {}; // ID: Rank

        // åŒºé–“ã”ã¨ã®é€Ÿåº¦åˆ¶å¾¡ç”¨é…åˆ—
        let segmentRates = [];

        // ==========================================
        //  ã‚³ãƒ¡ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿
        // ==========================================
        const courseComments = [
            { lat: 34.7622, lon: 138.7757, text: "<b>ğŸš© ã‚¹ã‚¿ãƒ¼ãƒˆï¼šæ¾å´æ¸¯</b><br>Aãƒ–ãƒ­ãƒƒã‚¯ã®å…ˆé ­é›†å›£ã®ã‚¹ã‚¿ãƒ¼ãƒˆã¯è¿«åŠ›ã‚ã‚‹ã‚ˆãƒ¼ã€‚" },
            { lat: 34.78945, lon: 138.83531, text: "<b>â›°ï¸ å®è”µé™¢</b><br>ã“ã“ã¾ã§å…¨éƒ¨ã®ã¼ã‚Šãƒ¼" },
            { lat: 34.7841, lon: 138.8448, text: "<b>ğŸŒ² å…«ç€¬å³ </b><br>èµ°ã‚Œã‚‹æ—é“ã€‚ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ©ãƒƒã‚¯æŠœã‘ãŸå¾Œã ã‘ã©è¶³æ¸©å­˜ã§ã€‚" },
            { lat: 34.8098, lon: 138.8808, text: "<b>ğŸ”ï¸ è«¸åªå³ </b><br>ã“ã“ã‹ã‚‰ãŒã£ã¤ã‚Šä¸‹ã‚Šã§èµ°ã‚Œã¡ã‚ƒã†ã€‚å»å¹´ã¯æ¸…å®®ã•ã‚“ã“ã“ã§è»¢ã‚“ã§DNFã—ã¦ã¾ã™ã€‚" },
            { lat: 34.81527, lon: 138.89888, text: "<b>ğŸ¡ ã“ãŒã­æ©‹ã‚¨ã‚¤ãƒ‰</b><br>æ¡œè‘‰ã‚‚ã¡ã¯ä¸€äººã²ã¨ã¤ã­<br>ã“ã“ã‹ã‚‰äºŒæœ¬æ‰ã¾ã§ãŒã£ã¤ã‚Šç™»ã‚‹ã‚ˆãƒ¼" },
            { lat: 34.82977, lon: 138.90792, text: "<b>ğŸ”ï¸ äºŒæœ¬æ‰å³ </b>" },
            { lat: 34.86169, lon: 138.84546, text: "<b>ğŸ”­ ä»ç§‘å±•æœ›å°</b>" },
            { lat: 34.87064, lon: 138.84383, text: "<b>ğŸ ä»ç§‘ã‚¨ã‚¤ãƒ‰</b><br>å¡©ã‚«ãƒ„ã‚ªã†ã©ã‚“ã¯é£Ÿã¹ã¦ã£ã¦ï¼ï¼" },
            { lat: 34.93452, lon: 138.83172, text: "<b>ğŸ² åœŸè‚¥é§è»Šå ´ã‚¨ã‚¤ãƒ‰</b><br>ã—ã—æ±ã¨ã„ã†åã®è±šæ±ï¼" },
            { lat: 34.93624, lon: 138.83371, text: "ã“ã“ã§æŒ¯ã‚Šå‘ã„ãŸã‚‰é§¿æ²³æ¹¾ãŒç¶ºéº—ã«è¦‹ãˆã‚‹ã‚ˆ" },
            { lat: 34.95498, lon: 138.83926, text: "<b>ğŸ”ï¸ é”ç£¨å±±</b><br>æ™´ã‚Œã¦ãŸã‚‰ç´ æ•µãªæ™¯è‰²ï¼ï¼æ™´ã‚Œã¦ãŸã‚‰ï¼ï¼" },
            { lat: 34.96425, lon: 138.83842, text: "<b>ğŸ”ï¸ å°é”ç£¨å±±</b><br>ã“ã‚ŒãŒãƒ©ã‚¹ãƒœã‚¹ã€‚å¾Œã¯é™ã‚‹ã ã‘ã€‚" },
            { lat: 34.97410, lon: 138.83662, text: "èŠç”Ÿãµã‹ãµã‹ã”è¤’ç¾ããƒ¼ã‚“ã ã‚ˆ" },
            { lat: 34.97532, lon: 138.85052, text: "ãƒˆã‚¤ãƒ¬ã‚ã‚‹ã‚ˆã€‚ãƒ–ãƒªãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã§ã¯é–‰é–ã•ã‚Œã¦ã‚‹ã£ã¦è¨€ã£ã¦ãŸã‘ã©ã€‚" },
            { lat: 34.97501, lon: 138.85045, text: "ã“ã®è¾ºã¯ã‚¬ãƒ¬ã‚¬ãƒ¬ã€‚æ»æŒ«æ³¨æ„ã­" },
            { lat: 34.97087, lon: 138.86076, text: "åœ°å‘³ã«ç™»ã£ã¦ã‚‹æ°—ãŒã™ã‚‹ã‘ã©æ°—ã®ã›ã„ã ã‹ã‚‰ã­ã€‚" },
            { lat: 34.96631, lon: 138.89426, text: "<b>âš ï¸ æ³¨æ„</b><br>ã“ã®ã‚ãŸã‚Šã ã£ãŸã¨æ€ã†ã‚“ã ã‘ã©ã€ã„ããªã‚Šå‡¹ã‚“ã§ã‚‹ã¨ã“ã‚ã‚‹ã‹ã‚‰æ°—ã‚’ä»˜ã‘ã¦ï¼ï¼" },
            { lat: 34.96885, lon: 138.90517, text: "ã“ã“ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ï¼ï¼ã¿ã‚“ãªæ„å¤–ã¨ã¡ã‚ƒã‚“ã¨èµ°ã‚‹ã‚ˆ" },
            { lat: 34.97038, lon: 138.92860, text: "<b>â™¨ï¸ ã‚´ãƒ¼ãƒ«ï¼šä¿®å–„å¯º</b>" }
        ];

        const CHECKPOINT_TARGETS = [
            { keyword: "å®è”µé™¢", targetTime: 4500 },
            { keyword: "ã“ãŒã­æ©‹", targetTime: 11400 },
            { keyword: "ä»ç§‘ã‚¨ã‚¤ãƒ‰", targetTime: 21300 },
            { keyword: "åœŸè‚¥é§è»Šå ´", targetTime: 29700 },
            { keyword: "ã‚´ãƒ¼ãƒ«", targetTime: 39300 }
        ];

        // å®Ÿæ³å¯¾è±¡ã¨ã™ã‚‹ãƒã‚¤ãƒ³ãƒˆã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ
        // ãƒ‡ãƒ¼ã‚¿ä¸Šã®è¡¨è¨˜ã«åˆã‚ã›ã¦è¨­å®š ("ã ã‚‹ã¾å±±" -> "é”ç£¨å±±" ãªã©)
        const COMMENTARY_TARGET_KEYWORDS = [
            "å®è”µé™¢",
            "å…«ç€¬å³ ",
            "è«¸åªå³ ",
            "ã“ãŒã­æ©‹",
            "äºŒæœ¬æ‰",
            "ä»ç§‘ã‚¨ã‚¤ãƒ‰",
            "åœŸè‚¥",
            "é”ç£¨å±±", // ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®š: ã ã‚‹ã¾å±±
            "ã‚´ãƒ¼ãƒ«"
        ];

        // ==========================================
        //  ã‚µãƒ³ãƒ—ãƒ«GPXãƒ‡ãƒ¼ã‚¿
        // ==========================================
        const sampleGpxLines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<gpx version="1.1" creator="Sample" xmlns="http://www.topografix.com/GPX/1/1">',
            '  <trk>',
            '    <name>ITJ Sample</name>',
            '    <trkseg>',
            // æ¾å´æ¸¯ã‹ã‚‰ä¿®å–„å¯ºã¾ã§ã®ç°¡æ˜“ãƒ«ãƒ¼ãƒˆ
            '      <trkpt lat="34.7540" lon="138.7760"><ele>5</ele></trkpt>',
            '      <trkpt lat="34.7600" lon="138.7850"><ele>50</ele></trkpt>',
            '      <trkpt lat="34.7650" lon="138.7950"><ele>100</ele></trkpt>',
            '      <trkpt lat="34.7700" lon="138.8100"><ele>400</ele></trkpt>',
            '      <trkpt lat="34.7750" lon="138.8200"><ele>550</ele></trkpt>',
            '      <trkpt lat="34.7850" lon="138.8300"><ele>700</ele></trkpt>', // å®è”µé™¢
            '      <trkpt lat="34.7900" lon="138.8400"><ele>600</ele></trkpt>',
            '      <trkpt lat="34.8000" lon="138.8500"><ele>500</ele></trkpt>',
            '      <trkpt lat="34.8100" lon="138.8600"><ele>700</ele></trkpt>',
            '      <trkpt lat="34.8200" lon="138.8700"><ele>900</ele></trkpt>', // å…«ç€¬å³ 
            '      <trkpt lat="34.8300" lon="138.8800"><ele>880</ele></trkpt>',
            '      <trkpt lat="34.8400" lon="138.8900"><ele>850</ele></trkpt>',
            '      <trkpt lat="34.8500" lon="138.9000"><ele>920</ele></trkpt>',
            '      <trkpt lat="34.8600" lon="138.9100"><ele>1000</ele></trkpt>', // ä»ç§‘å³ 
            '      <trkpt lat="34.8700" lon="138.9150"><ele>980</ele></trkpt>',
            '      <trkpt lat="34.8800" lon="138.9200"><ele>950</ele></trkpt>',
            '      <trkpt lat="34.8900" lon="138.9250"><ele>880</ele></trkpt>',
            '      <trkpt lat="34.9000" lon="138.9300"><ele>800</ele></trkpt>', // åœŸè‚¥å³ 
            '      <trkpt lat="34.9100" lon="138.9350"><ele>850</ele></trkpt>',
            '      <trkpt lat="34.9200" lon="138.9380"><ele>950</ele></trkpt>',
            '      <trkpt lat="34.9300" lon="138.9400"><ele>980</ele></trkpt>', // é”ç£¨å±±
            '      <trkpt lat="34.9380" lon="138.9430"><ele>900</ele></trkpt>', // å°é”ç£¨å±±
            '      <trkpt lat="34.9500" lon="138.9500"><ele>600</ele></trkpt>',
            '      <trkpt lat="34.9600" lon="138.9600"><ele>300</ele></trkpt>',
            '      <trkpt lat="34.9720" lon="138.9660"><ele>50</ele></trkpt>',  // ä¿®å–„å¯º
            '    </trkseg>',
            '  </trk>',
            '</gpx>'
        ];
        const sampleGpxData = sampleGpxLines.join("\n");

        let map;
        let currentTrackLayer = null;
        let commentLayer = null;
        let isZenMode = false;
        let gpxPoints = []; 
        let routeTotalDistance = 0;
        let minEle = 0, maxEle = 0; 
        
        let isPlaying = false;
        let animReqId = null;

        // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°å®šç¾© ---

        window.handleFileSelect = function(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                processGPX(e.target.result);
            };
            reader.readAsText(file);
        };

        // ç”»åƒã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦URLã‚’è¿”ã™é–¢æ•°
        function getIconUrl(config) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(config.fileName); // èª­ã¿è¾¼ã¿æˆåŠŸãªã‚‰ãã®ãƒ•ã‚¡ã‚¤ãƒ«å
                img.onerror = () => {
                    // èª­ã¿è¾¼ã¿å¤±æ•—ãªã‚‰ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
                    const fallbackUrl = `https://placehold.co/40x40/${config.color.substring(1)}/ffffff?text=${config.fallbackText}`;
                    resolve(fallbackUrl);
                };
                img.src = config.fileName;
            });
        }

        // å¿œæ´ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡
        window.openCheerModal = function() {
            const modal = document.getElementById('cheerModal');
            const list = document.getElementById('cheerRunnerList');
            list.innerHTML = ''; // ã‚¯ãƒªã‚¢

            runners.forEach((r, i) => {
                // çµ‚äº†ã—ãŸãƒ©ãƒ³ãƒŠãƒ¼ã¯å¿œæ´ã§ããªã„ã“ã¨ã«ã™ã‚‹
                if (r.finished) return;

                const btn = document.createElement('button');
                btn.className = "w-full bg-blue-50 hover:bg-blue-100 text-blue-700 font-semibold py-3 px-4 rounded border border-blue-200 flex items-center justify-between";
                btn.onclick = () => applyCheer(i);
                
                // ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤ºç”¨HTML
                const iconHtml = `<img src="${r.marker.options.icon.options.iconUrl}" class="w-8 h-8 rounded-full border border-gray-300 bg-white object-cover">`;
                
                btn.innerHTML = `
                    <div class="flex items-center gap-3">
                        ${iconHtml}
                        <span>${r.name}</span>
                    </div>
                    <span class="text-xs bg-yellow-400 text-white px-2 py-1 rounded-full">Boost!</span>
                `;
                list.appendChild(btn);
            });

            if (list.children.length === 0) {
                list.innerHTML = '<div class="text-gray-500 py-4">å¿œæ´ã§ãã‚‹ãƒ©ãƒ³ãƒŠãƒ¼ãŒã„ã¾ã›ã‚“</div>';
            }

            modal.style.display = 'flex';
        };

        window.closeCheerModal = function() {
            document.getElementById('cheerModal').style.display = 'none';
        };

        window.applyCheer = function(runnerIdx) {
            const r = runners[runnerIdx];
            if (!r) return;

            // å¿œæ´åŠ¹æœ: é€Ÿåº¦ã‚¢ãƒƒãƒ— & ã‚¹ã‚¿ãƒŸãƒŠå°‘ã—å›å¾©ï¼ˆæ°¸ç¶šï¼‰
            r.baseSpeed *= 1.1; 
            r.stamina = Math.min(1.5, r.stamina * 1.05);

            // AIå®Ÿæ³ç”¨ã«ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ 
            raceEvents.push(`ã€å¿œæ´ã€‘${r.name}é¸æ‰‹ã«å¿œæ´ãŒå…¥ã‚Šã¾ã—ãŸï¼ãƒšãƒ¼ã‚¹ãŒä¸ŠãŒã£ã¦ã„ã¾ã™ï¼`);

            // æ¼”å‡º: ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— (ãƒ©ãƒ³ãƒŠãƒ¼ã®ä½ç½®ã«è¡¨ç¤º)
            const p = gpxPoints[Math.floor(r.idx)];
            if (p) {
                const popup = L.popup({
                    offset: [0, -40],
                    autoClose: false,
                    closeOnClick: false,
                    closeButton: false,
                    className: 'cheer-popup font-bold text-yellow-600'
                })
                .setLatLng([p.lat, p.lon])
                .setContent(`<div class="text-center animate-bounce">å¿œæ´ã‚ã‚ŠãŒã¨ãƒ¼ï¼ï¼<br><span class="text-xs text-gray-500">to ${r.name}</span></div>`);
                map.addLayer(popup);
                setTimeout(() => map.removeLayer(popup), 2000);
            }

            closeCheerModal();
        };

        // ãƒªã‚¶ãƒ«ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡
        window.closeResultModal = function() {
            document.getElementById('resultModal').style.display = 'none';
        };

        window.showResultModal = function() {
            const modal = document.getElementById('resultModal');
            const podiumArea = document.getElementById('podiumArea');
            const listArea = document.getElementById('resultListArea');
            
            // ã‚¿ã‚¤ãƒ é †ã«ã‚½ãƒ¼ãƒˆ (ã‚´ãƒ¼ãƒ«æ¸ˆã¿ã®ã¿ã‚’æƒ³å®šã€ä¸‡ãŒä¸€æœªã‚´ãƒ¼ãƒ«ãŒã„ã¦ã‚‚æœ€å¾Œå°¾ã¸)
            const sorted = [...runners].sort((a, b) => {
                if(a.finished && b.finished) return a.finishTime.localeCompare(b.finishTime);
                if(a.finished) return -1;
                return 1;
            });
            
            // è¡¨å½°å°ç”Ÿæˆ (Top 3)
            let podiumHTML = '';
            // è¡¨ç¤ºé †: 2ä½, 1ä½, 3ä½
            const podiumOrder = [1, 0, 2]; 
            
            podiumOrder.forEach(idx => {
                if (!sorted[idx]) return; // ãƒ©ãƒ³ãƒŠãƒ¼ãŒè¶³ã‚Šãªã„å ´åˆã‚¹ã‚­ãƒƒãƒ—
                const r = sorted[idx];
                const rank = idx + 1; // å®Ÿéš›ã®é †ä½
                
                podiumHTML += `
                    <div class="podium-item rank-${rank}">
                        <div class="podium-rank">${rank}</div>
                        <img src="${r.marker.options.icon.options.iconUrl}" class="podium-icon">
                        <div class="podium-base text-xs flex-col justify-end pb-2">
                            <span>${r.name}</span>
                        </div>
                    </div>
                `;
            });
            podiumArea.innerHTML = podiumHTML;

            // ãƒªã‚¹ãƒˆç”Ÿæˆ
            let listHTML = '';
            sorted.forEach((r, i) => {
                const rank = i + 1;
                const time = r.finished ? r.finishTime : "DNF";
                listHTML += `
                    <div class="result-row">
                        <div class="flex items-center gap-3">
                            <span class="font-bold w-6 text-center text-gray-500">${rank}</span>
                            <img src="${r.marker.options.icon.options.iconUrl}" class="w-8 h-8 rounded-full border border-gray-200">
                            <span class="font-medium text-gray-800">${r.name}</span>
                        </div>
                        <div class="font-mono font-bold text-blue-600">${time}</div>
                    </div>
                `;
            });
            listArea.innerHTML = listHTML;

            modal.style.display = 'flex';
        };

        window.toggleZenMode = function() {
            const header = document.getElementById('appHeader');
            isZenMode = !isZenMode;
            header.style.display = isZenMode ? 'none' : 'flex';
            setTimeout(() => map.invalidateSize(), 300);
        };

        window.fitBoundsToTrack = function() {
            if (currentTrackLayer) {
                const group = commentLayer ? L.featureGroup([currentTrackLayer, commentLayer]) : currentTrackLayer;
                map.fitBounds(group.getBounds(), { padding: [20, 20] });
            }
        };

        window.togglePlay = function() {
            if (gpxPoints.length === 0) return;
            isPlaying = !isPlaying;
            const playIcon = document.getElementById('icon-play');
            const pauseIcon = document.getElementById('icon-pause');

            if (isPlaying) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                
                // AIå®Ÿæ³ãƒ«ãƒ¼ãƒ—é–‹å§‹
                startAiCommentaryLoop();

                // ã‚‚ã—å…¨å“¡ã‚´ãƒ¼ãƒ«æ¸ˆã¿ãªã‚‰ãƒªã‚»ãƒƒãƒˆã—ã¦ã‹ã‚‰å†ç”Ÿ
                if (runners.every(r => r.finished)) {
                    resetAnimation();
                    // resetAnimationå†…ã§åœæ­¢ã•ã‚Œã‚‹ã®ã§ã€å†åº¦å†ç”Ÿãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã¦ãƒ«ãƒ¼ãƒ—é–‹å§‹
                    isPlaying = true;
                    playIcon.classList.add('hidden');
                    pauseIcon.classList.remove('hidden');
                    animLoop();
                } else {
                    animLoop();
                }
            } else {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                cancelAnimationFrame(animReqId);
                // AIå®Ÿæ³ãƒ«ãƒ¼ãƒ—åœæ­¢
                stopAiCommentaryLoop();
            }
        };

        window.resetAnimation = function() {
            isPlaying = false;
            cancelAnimationFrame(animReqId);
            stopAiCommentaryLoop(); // ãƒªã‚»ãƒƒãƒˆæ™‚ã‚‚åœæ­¢
            initRunners();
            elapsedTime = 0; 
            raceEvents = []; // ã‚¤ãƒ™ãƒ³ãƒˆã‚¯ãƒªã‚¢
            updatePlayerUI();
            updateTimerDisplay();
            document.getElementById('icon-play').classList.remove('hidden');
            document.getElementById('icon-pause').classList.add('hidden');
            map.closePopup();
            if(gpxPoints.length > 0) {
                map.panTo([gpxPoints[0].lat, gpxPoints[0].lon]);
            }
        };

        window.seekAnimation = function(val) {
            const ratio = parseInt(val) / 100;
            const targetIdx = Math.floor((gpxPoints.length - 1) * ratio);
            
            const totalEstimatedSeconds = CHECKPOINT_TARGETS[CHECKPOINT_TARGETS.length-1].targetTime; 
            elapsedTime = totalEstimatedSeconds * ratio;

            runners.forEach(r => {
                let variation = (r.baseSpeed - 1.0) * (gpxPoints.length * 0.1); 
                let idx = targetIdx + variation;
                if (idx < 0) idx = 0;
                if (idx >= gpxPoints.length - 1) idx = gpxPoints.length - 1;
                
                r.idx = idx;
                r.finished = false;
                r.state = 'run';
                r.resumeTime = 0; 
                // seekã—ãŸå ´åˆã¯é€šéãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãªã©ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ã®ãŒç†æƒ³ã ãŒç°¡æ˜“çš„ã«ãã®ã¾ã¾
                r.lastCheckpointIdx = -1;
            });
            updatePlayerUI();
            updateTimerDisplay();
        };

        window.changeSpeed = function() {
            const currentIdx = SPEED_OPTIONS.indexOf(PLAY_SPEED);
            const nextIdx = (currentIdx + 1) % SPEED_OPTIONS.length;
            PLAY_SPEED = SPEED_OPTIONS[nextIdx];
            document.getElementById('speedBtn').textContent = "x" + PLAY_SPEED;
        };

        // ==========================================
        //  AIå®Ÿæ³é–¢é€£
        // ==========================================
        window.toggleAiCommentary = function() {
            isAiCommentaryOn = !isAiCommentaryOn;
            const btn = document.getElementById('btnAiToggle');
            const box = document.getElementById('aiCommentaryBox');
            
            if (isAiCommentaryOn) {
                btn.classList.remove('bg-gray-400', 'border-gray-500');
                btn.classList.add('bg-purple-600', 'border-purple-800');
                btn.textContent = "AI ON";
                box.style.display = "flex";
                if (isPlaying) startAiCommentaryLoop();
            } else {
                btn.classList.remove('bg-purple-600', 'border-purple-800');
                btn.classList.add('bg-gray-400', 'border-gray-500');
                btn.textContent = "AI OFF";
                box.style.display = "none";
                stopAiCommentaryLoop();
            }
        };

        function startAiCommentaryLoop() {
            if (!isAiCommentaryOn || aiInterval) return;
            // åˆå›å³å®Ÿè¡Œ
            generateRaceCommentary();
            // ãã®å¾Œå®šæœŸå®Ÿè¡Œ (20ç§’ã”ã¨)
            aiInterval = setInterval(generateRaceCommentary, 20000);
        }

        function stopAiCommentaryLoop() {
            if (aiInterval) {
                clearInterval(aiInterval);
                aiInterval = null;
            }
        }

        async function callGemini(text) {
            if (!apiKey) return "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€AIå®Ÿæ³ã¯ç”Ÿæˆã•ã‚Œã¾ã›ã‚“ã€‚";

            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }]
            };

            // Exponential backoff
            const delays = [1000, 2000, 4000];
            for (let i = 0; i < delays.length; i++) {
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.ok) {
                        const data = await response.json();
                        return data.candidates?.[0]?.content?.parts?.[0]?.text || "å®Ÿæ³ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
                    }
                } catch (e) {
                    // retry
                }
                await new Promise(r => setTimeout(r, delays[i]));
            }
            return "é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚";
        }

        async function generateRaceCommentary() {
            if (gpxPoints.length === 0) return;
            if (!isAiCommentaryOn) return;

            const contentEl = document.getElementById('aiCommentaryText');
            
            // ãƒ¬ãƒ¼ã‚¹çŠ¶æ³ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
            const sortedRunners = [...runners].sort((a, b) => b.idx - a.idx);
            
            // ä¸Šä½3åã®ã¿æŠ½å‡º
            const top3 = sortedRunners.slice(0, 3).map((r, i) => {
                const dist = gpxPoints[Math.floor(r.idx)] ? (gpxPoints[Math.floor(r.idx)].totalDist / 1000).toFixed(1) : 0;
                return `${i+1}ä½:${r.name}(${dist}km)`;
            }).join(", ");

            // ç›´è¿‘ã®ã‚¤ãƒ™ãƒ³ãƒˆ (æœ€å¤§3ã¤) ã‚’æŠ½å‡ºã™ã‚‹éš›ã€é‡è¦åº¦é †ã«ã‚½ãƒ¼ãƒˆã™ã‚‹
            // å„ªå…ˆåº¦: è¿½ã„æŠœã > é€šé/ã‚´ãƒ¼ãƒ« > ãã®ä»–
            const prioritizedEvents = [...raceEvents].sort((a, b) => {
                const getScore = (text) => {
                    if (text.includes("è¿½ã„æŠœã")) return 3;
                    if (text.includes("ã‚´ãƒ¼ãƒ«")) return 2;
                    if (text.includes("é€šé")) return 1;
                    return 0;
                };
                return getScore(b) - getScore(a); // é™é †
            });

            // ä¸Šä½3ã¤ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¡ç”¨ã€ãªã‘ã‚Œã°ç©º
            const recentEvents = prioritizedEvents.slice(0, 3).join("ã€");
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢ï¼ˆæ¡ç”¨ã—ãªã‹ã£ãŸã‚‚ã®ã‚‚å«ã‚ã¦ã‚¯ãƒªã‚¢ã—ã¦OKã€å¤ã„ãƒ‹ãƒ¥ãƒ¼ã‚¹ã«ãªã‚‹ãŸã‚ï¼‰
            raceEvents = []; 

            const prompt = `
                ã‚ãªãŸã¯ä¼Šè±†ãƒˆãƒ¬ã‚¤ãƒ«ã‚¸ãƒ£ãƒ¼ãƒ‹ãƒ¼(ITJ)ã®å®Ÿæ³ã‚¢ãƒŠã‚¦ãƒ³ã‚µãƒ¼ã§ã™ã€‚
                
                ã€ç¾åœ¨ã®çŠ¶æ³ã€‘
                çµŒéæ™‚é–“: ${document.getElementById('raceTimer').textContent}
                ãƒˆãƒƒãƒ—é›†å›£: ${top3}
                
                ã€ç›´è¿‘ã®å‡ºæ¥äº‹ã€‘
                ${recentEvents || "ç¾åœ¨ã€è† ç€çŠ¶æ…‹ã§ã™ã€‚"}

                ä¸Šè¨˜ã€ç›´è¿‘ã®å‡ºæ¥äº‹ã€‘ã‚’ã‚‚ã¨ã«å®Ÿæ³ã‚³ãƒ¡ãƒ³ãƒˆã‚’**50æ–‡å­—ä»¥å†…**ã§ä½œæˆã—ã¦ãã ã•ã„ã€‚
                ç‰¹ã«ã€Œè¿½ã„æŠœãã€ã‚„ã€Œé †ä½å¤‰å‹•ã€ã®æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯ã€ãã‚Œã‚’**æœ€å„ªå…ˆ**ã§èˆˆå¥®æ°—å‘³ã«ä¼ãˆã¦ãã ã•ã„ã€‚
                HTMLã‚¿ã‚°ã¯ä¸å¯ã€‚
            `;

            let commentary = "";
            if (!apiKey) {
                // ãƒ€ãƒŸãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆ (APIã‚­ãƒ¼ãŒãªã„å ´åˆç”¨)
                if (recentEvents) {
                    commentary = `ãŠã£ã¨ï¼${recentEvents} å±•é–‹ãŒå‹•ã„ã¦ã„ã¾ã™ï¼`;
                } else {
                    const phrases = [
                        "ã•ã‚ã€ãƒ¬ãƒ¼ã‚¹ã¯ä¸­ç›¤æˆ¦ï¼å„é¸æ‰‹æ‡¸å‘½ãªèµ°ã‚Šã‚’è¦‹ã›ã¦ã„ã¾ã™ï¼",
                        "ç¾ã—ã„ä¼Šè±†ã®å±±ã€…ã‚’ãƒ©ãƒ³ãƒŠãƒ¼ãŸã¡ãŒé§†ã‘æŠœã‘ã¦ã„ãã¾ã™ï¼",
                        "é ‘å¼µã‚Œï¼ã‚´ãƒ¼ãƒ«ã¯ã‚‚ã†ã™ãã ï¼ãƒ©ã‚¹ãƒˆã‚¹ãƒ‘ãƒ¼ãƒˆï¼",
                    ];
                    commentary = phrases[Math.floor(Math.random() * phrases.length)];
                }
            } else {
                try {
                    commentary = await callGemini(prompt);
                } catch (e) {
                    commentary = "AIå®Ÿæ³ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
                }
            }

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ãŸã‚ã«è¦ç´ ã‚’æ›¸ãæ›ãˆã‚‹
            const newSpan = document.createElement('span');
            newSpan.textContent = commentary + "ã€€ã€€ã€€ã€€"; // ä½™ç™½ã‚’å…¥ã‚Œã‚‹
            
            // ä¸€ç¬ãƒªã‚»ãƒƒãƒˆ
            contentEl.style.animation = 'none';
            contentEl.textContent = commentary;
            contentEl.offsetHeight; /* trigger reflow */
            contentEl.style.animation = 'marquee 20s linear infinite';
        }

        // --- åˆæœŸåŒ– ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            loadGpxFile();
            addComments();
        });

        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([34.86, 138.91], 11);
            L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', {
                maxZoom: 18,
                attribution: '&copy; <a href="https://maps.gsi.go.jp/development/ichiran.html">å›½åœŸåœ°ç†é™¢</a>'
            }).addTo(map);
            addLegend();

            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã®è¿½åŠ ï¼šã‚³ãƒ¼ã‚¹ä¸Šã®è·é›¢ã¨åº§æ¨™ã‚’è¡¨ç¤º
            map.on('click', function(e) {
                if (gpxPoints.length === 0) return;

                let nearestPoint = null;
                let minDistance = Infinity;
                const clickLat = e.latlng.lat;
                const clickLng = e.latlng.lng;

                // æœ€å¯„ã‚Šã®ã‚³ãƒ¼ã‚¹ä¸Šã®ç‚¹ã‚’æ¢ã™
                gpxPoints.forEach(p => {
                    const dist = map.distance([clickLat, clickLng], [p.lat, p.lon]);
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearestPoint = p;
                    }
                });

                // ã‚³ãƒ¼ã‚¹ã‹ã‚‰500mä»¥å†…ãªã‚‰ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º
                if (nearestPoint && minDistance < 500) {
                    const distKm = (nearestPoint.totalDist / 1000).toFixed(1);
                    
                    L.popup()
                        .setLatLng([nearestPoint.lat, nearestPoint.lon])
                        .setContent(`
                            <div class="text-center font-sans">
                                <span class="text-blue-600 font-bold text-lg">${distKm} kmåœ°ç‚¹</span>
                                <div class="text-xs text-gray-500 mt-1">
                                    Lat: ${nearestPoint.lat.toFixed(5)}<br>
                                    Lon: ${nearestPoint.lon.toFixed(5)}
                                </div>
                            </div>
                        `)
                        .openOn(map);
                }
            });
        }

        function addComments() {
            if (commentLayer) map.removeLayer(commentLayer);
            commentLayer = L.featureGroup();
            courseComments.forEach(comment => {
                const marker = L.marker([comment.lat, comment.lon])
                    .bindPopup(comment.text, { className: 'comment-popup', closeButton: false, autoClose: false });
                marker.addTo(commentLayer);
            });
            commentLayer.addTo(map);
        }

        function loadGpxFile() {
            // ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªã„ãŸã‚ã€å¸¸ã«catchãƒ–ãƒ­ãƒƒã‚¯ã¸è¡Œãã‚ˆã†ã«æ„å›³çš„ã«ã™ã‚‹ã€
            // ã‚‚ã—ãã¯fetchã§404ã«ãªã‚‹ã®ã§catchã§æ‹¾ã‚ã‚Œã‚‹ã¯ãšã€‚
            fetch(GPX_FILE_URL)
                .then(r => r.ok ? r.text() : Promise.reject(r.status))
                .then(text => processGPX(text))
                .catch(() => {
                    console.warn("å¤–éƒ¨GPXèª­ã¿è¾¼ã¿å¤±æ•—ã€‚ã‚µãƒ³ãƒ—ãƒ«ã‚’ä½¿ç”¨ã€‚");
                    processGPX(sampleGpxData);
                });
        }

        function identifyAidStations() {
            aidStationIndices = [];
            courseComments.forEach(c => {
                if (c.text.includes("ã‚¨ã‚¤ãƒ‰") || c.text.includes("ä¼‘æ†©") || c.text.includes("é§è»Šå ´")) {
                    let minDist = Infinity;
                    let closestIdx = -1;
                    gpxPoints.forEach((p, i) => {
                        const d = map.distance([c.lat, c.lon], [p.lat, p.lon]);
                        if (d < minDist) {
                            minDist = d;
                            closestIdx = i;
                        }
                    });
                    if (closestIdx !== -1 && minDist < 200) { 
                        aidStationIndices.push(closestIdx);
                    }
                }
            });
        }

        function calculateSegmentRates() {
            segmentRates = [];
            let currentIdx = 0;
            let currentTime = 0;

            CHECKPOINT_TARGETS.forEach(target => {
                let targetIdx = -1;
                const comment = courseComments.find(c => c.text.includes(target.keyword));
                if (comment) {
                    let minDist = Infinity;
                    gpxPoints.forEach((p, i) => {
                        const d = map.distance([comment.lat, comment.lon], [p.lat, p.lon]);
                        if (d < minDist) {
                            minDist = d;
                            targetIdx = i;
                        }
                    });
                } else {
                    if (target.keyword === "ã‚´ãƒ¼ãƒ«") targetIdx = gpxPoints.length - 1;
                }

                if (targetIdx !== -1 && targetIdx > currentIdx) {
                    const distPoints = targetIdx - currentIdx; 
                    const durationSeconds = target.targetTime - currentTime; 
                    
                    if (durationSeconds > 0) {
                        const pointsPerFrame = distPoints / (durationSeconds / FRAME_DURATION);
                        segmentRates.push({
                            endIdx: targetIdx,
                            rate: pointsPerFrame
                        });
                    }
                    currentIdx = targetIdx;
                    currentTime = target.targetTime;
                }
            });
            
            if (currentIdx < gpxPoints.length - 1) {
                segmentRates.push({
                    endIdx: gpxPoints.length - 1,
                    rate: 1.0 
                });
            }
        }

        async function initRunners() {
            runners.forEach(r => { if(r.marker) map.removeLayer(r.marker); });
            runners = [];
            const startPt = gpxPoints[0] || {lat:0, lon:0};
            lastRankMap = {};

            const runnerPromises = RUNNER_CONFIGS.map(async (config, i) => {
                // ã‚¹ãƒ”ãƒ¼ãƒ‰: 0.85 ~ 1.15
                const randomSpeed = 0.85 + Math.random() * 0.3; 
                const randomStamina = 0.8 + Math.random() * 0.4;

                const iconUrl = await getIconUrl(config);

                const icon = L.icon({
                    iconUrl: iconUrl,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20],
                    className: 'custom-runner-icon'
                });

                const marker = L.marker([startPt.lat, startPt.lon], {
                    icon: icon,
                    zIndexOffset: 2000 - (i * 100) 
                }).addTo(map);
                
                marker.bindTooltip(config.name, { 
                    permanent: false, 
                    direction: 'top',
                    className: 'text-xs font-bold'
                });

                return {
                    id: i,
                    name: config.name,
                    color: config.color,
                    baseSpeed: randomSpeed, 
                    stamina: randomStamina, 
                    idx: 0, 
                    state: 'run', 
                    resumeTime: 0, 
                    restedStations: new Set(), 
                    finished: false,
                    finishTime: null, 
                    marker: marker,
                    lastCheckpointIdx: -1 
                };
            });

            runners = await Promise.all(runnerPromises);
            
            // åˆæœŸé †ä½ãƒãƒƒãƒ—ã®ä½œæˆ
            runners.forEach((r, i) => {
                lastRankMap[r.id] = i; 
            });

            document.getElementById('raceStatus').style.display = 'block';
            updateLeaderboard();
        }

        function processGPX(xmlString) {
            try {
                if (currentTrackLayer) {
                    map.removeLayer(currentTrackLayer);
                    currentTrackLayer = null;
                }

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                const trkpts = xmlDoc.getElementsByTagName("trkpt");

                if (trkpts.length === 0) return alert("ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“");

                let rawPoints = [];
                for (let i = 0; i < trkpts.length; i++) {
                    const lat = parseFloat(trkpts[i].getAttribute("lat"));
                    const lon = parseFloat(trkpts[i].getAttribute("lon"));
                    const ele = parseFloat(trkpts[i].getElementsByTagName("ele")[0]?.textContent || 0);
                    rawPoints.push({ lat, lon, ele });
                }

                if (REVERSE_GPX_ORDER) rawPoints.reverse();

                // === è£œé–“å‡¦ç† (ç´„10mã”ã¨) ===
                const interpolatedPoints = [];
                const INTERVAL = 10; 

                if (rawPoints.length > 0) {
                    interpolatedPoints.push(rawPoints[0]);
                    for (let i = 0; i < rawPoints.length - 1; i++) {
                        const p1 = rawPoints[i];
                        const p2 = rawPoints[i+1];
                        const dist = map.distance([p1.lat, p1.lon], [p2.lat, p2.lon]);
                        if (dist > INTERVAL) {
                            const steps = Math.floor(dist / INTERVAL);
                            for (let j = 1; j <= steps; j++) {
                                const ratio = j / (steps + 1);
                                const lat = p1.lat + (p2.lat - p1.lat) * ratio;
                                const lon = p1.lon + (p2.lon - p1.lon) * ratio;
                                const ele = p1.ele + (p2.ele - p1.ele) * ratio;
                                interpolatedPoints.push({ lat, lon, ele });
                            }
                        }
                        interpolatedPoints.push(p2);
                    }
                }

                const points = [];
                let totalDist = 0;
                minEle = Infinity;
                maxEle = -Infinity;

                for (let i = 0; i < interpolatedPoints.length; i++) {
                    const p = interpolatedPoints[i];
                    if (i > 0) {
                        const prev = interpolatedPoints[i-1];
                        const dist = map.distance([prev.lat, prev.lon], [p.lat, p.lon]);
                        totalDist += dist;
                    }
                    if (p.ele < minEle) minEle = p.ele;
                    if (p.ele > maxEle) maxEle = p.ele;
                    points.push({ lat: p.lat, lon: p.lon, ele: p.ele, totalDist: totalDist });
                }

                gpxPoints = points;
                routeTotalDistance = totalDist;

                document.getElementById('totalDistDisplay').textContent = "/ " + (totalDist / 1000).toFixed(1) + "km";
                document.getElementById('progressSlider').max = 100; 

                drawColoredTrack(points);
                drawElevationChart(points);
                
                // æ™‚é–“çµŒéã®ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
                if (routeTotalDistance > 0) {
                    const targetSeconds = 38400; // å¹³å‡ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
                    const totalFrames = routeTotalDistance / 10; // 10måˆ»ã¿
                    timeStep = targetSeconds / totalFrames;
                }

                identifyAidStations();
                calculateSegmentRates(); 
                initRunners();
                addComments(); 

            } catch (err) {
                console.error("GPXè§£æã‚¨ãƒ©ãƒ¼:", err);
                alert("GPXãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
            }
        }

        function drawElevationChart(points) {
            const path = document.getElementById('elevationPath');
            if (points.length < 2) return;
            let d = `M 0,100 `;
            const eleRange = maxEle - minEle;
            const eleBottom = minEle - eleRange * 0.1;
            const eleHeight = eleRange * 1.2; 
            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const x = (p.totalDist / routeTotalDistance) * 100;
                const y = 100 - ((p.ele - eleBottom) / eleHeight) * 100;
                d += `L ${x.toFixed(2)},${y.toFixed(2)} `;
            }
            d += `L 100,100 Z`;
            path.setAttribute('d', d);
        }

        function drawColoredTrack(points) {
            if (currentTrackLayer) map.removeLayer(currentTrackLayer);
            currentTrackLayer = L.featureGroup();
            const canvasRenderer = L.canvas({ padding: 0.5 });
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                const eleDiff = p2.ele - p1.ele;
                const dist = p2.totalDist - p1.totalDist;
                let color = "#66bd63";
                if (dist > 0) {
                    const gradient = (eleDiff / dist) * 100;
                    if (gradient >= 5) color = "#d73027";
                    else if (gradient >= 1) color = "#fc8d59";
                    else if (gradient > -1) color = "#66bd63";
                    else if (gradient > -5) color = "#4575b4";
                    else color = "#313695";
                }
                L.polyline([[p1.lat, p1.lon], [p2.lat, p2.lon]], {
                    color: color, weight: 5, opacity: 0.8, renderer: canvasRenderer
                }).addTo(currentTrackLayer);
            }
            currentTrackLayer.addTo(map);
            map.fitBounds(currentTrackLayer.getBounds(), { padding: [20, 20] });
        }

        function addLegend() {
            const legend = L.control({position: 'topright'});
            legend.onAdd = function () {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = `
                    <div style="font-weight:bold; margin-bottom:4px; border-bottom:1px solid #ddd;">å‹¾é…</div>
                    <div><i style="background: #d73027"></i> æ€¥ãªä¸Šã‚Š</div>
                    <div><i style="background: #fc8d59"></i> ä¸Šã‚Š</div>
                    <div><i style="background: #66bd63"></i> å¹³å¦</div>
                    <div><i style="background: #4575b4"></i> ä¸‹ã‚Š</div>
                    <div><i style="background: #313695"></i> æ€¥ãªä¸‹ã‚Š</div>
                `;
                return div;
            };
            legend.addTo(map);
        }

        function animLoop() {
            if (!isPlaying) return;
            
            let anyoneRunning = false;
            
            elapsedTime += FRAME_DURATION * PLAY_SPEED; 
            updateTimerDisplay();

            runners.forEach(r => {
                if (r.finished) return;
                anyoneRunning = true;

                // ä¼‘æ†©å‡¦ç†: æ™‚é–“ãƒ™ãƒ¼ã‚¹ã«å¤‰æ›´
                if (r.state === 'stop') {
                    if (elapsedTime >= r.resumeTime) {
                        r.state = 'run';
                        r.idx += 1.0; 
                    }
                    return; 
                }

                aidStationIndices.forEach((aidIdx, aidId) => {
                    if (Math.abs(r.idx - aidIdx) < 5 && !r.restedStations.has(aidId)) {
                        if (Math.random() < 0.9) {
                            r.state = 'stop';
                            // ä¼‘æ†©æ™‚é–“: 1åˆ†(60ç§’) ~ 10åˆ†(600ç§’)
                            const restDuration = 60 + Math.random() * 540; 
                            r.resumeTime = elapsedTime + restDuration;
                            r.restedStations.add(aidId);
                        } else {
                            r.restedStations.add(aidId);
                        }
                    }
                });

                if (r.state === 'stop') return;

                let segmentRate = 1.0;
                for (let seg of segmentRates) {
                    if (r.idx < seg.endIdx) {
                        segmentRate = seg.rate;
                        break;
                    }
                }

                const progress = r.idx / (gpxPoints.length - 1);
                const staminaFactor = 1.0 + (r.stamina - 1.0) * progress; 
                const noise = 0.9 + Math.random() * 0.2; 
                
                const moveAmount = segmentRate * r.baseSpeed * PLAY_SPEED * noise * Math.max(0.5, staminaFactor);
                
                r.idx += moveAmount;

                // --- ã‚¤ãƒ™ãƒ³ãƒˆæ¤œçŸ¥ (é€šé) ---
                if (gpxPoints.length > 0) {
                    const currentIdx = Math.floor(r.idx);
                    
                    // å®‰å…¨ç­–: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¯„å›²ãƒã‚§ãƒƒã‚¯ & myPoså–å¾—ãƒã‚§ãƒƒã‚¯
                    if (currentIdx >= 0 && currentIdx < gpxPoints.length) {
                        const myPos = gpxPoints[currentIdx];

                        // ã¾ã é€šéã—ã¦ã„ãªã„ã‚³ãƒ¡ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
                        courseComments.forEach((c) => {
                            // ã‚³ãƒ¡ãƒ³ãƒˆåœ°ç‚¹ã«è¿‘ã„GPXãƒã‚¤ãƒ³ãƒˆã‚’æ¢ã™ï¼ˆãƒ­ãƒ¼ãƒ‰æ™‚ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã—ã¦ãŠãã®ãŒåŠ¹ç‡çš„ã ãŒä»Šå›ã¯ç°¡æ˜“æ¤œç´¢ï¼‰
                            // æ—¢ã«ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã®å ´æ‰€ã‚ˆã‚Šå…ˆã«ã‚ã‚‹ã‹åˆ¤å®š
                            if (r.lastCheckpointIdx < currentIdx) {
                                let minDist = Infinity;
                                let cIdx = -1;
                                // å‘¨è¾ºæ¢ç´¢ (å…¨æ¢ç´¢ã¯é‡ã„ã®ã§ã€ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å‘¨è¾º Â±100ç‚¹ãã‚‰ã„ã‚’è¦‹ã‚‹)
                                // ç°¡æ˜“çš„ã«è·é›¢åˆ¤å®š
                                
                                const dist = map.distance([myPos.lat, myPos.lon], [c.lat, c.lon]);
                                
                                // 100mä»¥å†…ã§ã€ã‹ã¤å‰å›ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚ˆã‚Šå…ˆãªã‚‰é€šéã¨ã¿ãªã™
                                // (ãŸã ã—ã‚¤ãƒ™ãƒ³ãƒˆã®é‡è¤‡ã‚’é˜²ããŸã‚ã€å˜ç´”ã«ã€Œæœ€ã‚‚è¿‘ã„ãƒã‚¤ãƒ³ãƒˆã‚’é€šéã—ãŸç¬é–“ã€ã‚’æ‰ãˆã‚‹ã®ã¯é›£ã—ã„ã®ã§
                                //  è·é›¢ãŒè¿‘ã¥ã„ãŸã¨ãã«1å›ã ã‘ç™ºç«ã•ã›ã‚‹ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯ã«ã™ã‚‹)
                                // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œç‰¹å®šã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯åã‚’å«ã‚€ã‚³ãƒ¡ãƒ³ãƒˆåœ°ç‚¹ã€ã‚’é€šéã—ãŸã‹ãƒã‚§ãƒƒã‚¯
                                if (dist < 50 && !r.passedLandmarks?.has(c.text)) {
                                    if (!r.passedLandmarks) r.passedLandmarks = new Set();
                                    r.passedLandmarks.add(c.text);
                                    
                                    // HTMLã‚¿ã‚°é™¤å»ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º
                                    const plainText = c.text.replace(/<[^>]*>/g, '');
                                    
                                    // æŒ‡å®šã•ã‚ŒãŸä¸»è¦ãƒã‚¤ãƒ³ãƒˆã®ã¿å®Ÿæ³ã‚¤ãƒ™ãƒ³ãƒˆã«è¿½åŠ ã™ã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                                    const matchedKeyword = COMMENTARY_TARGET_KEYWORDS.find(keyword => plainText.includes(keyword));
                                    
                                    if (matchedKeyword) {
                                        // å®Ÿæ³ç”¨ã«å°‘ã—è¡¨è¨˜ã‚’æ•´ãˆã‚‹ï¼ˆ"åœŸè‚¥" -> "åœŸè‚¥é§è»Šå ´ã‚¨ã‚¤ãƒ‰"ãªã©å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æ´»ã‹ã™ã‹ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã†ã‹ï¼‰
                                        // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã†ã€ã¾ãŸã¯å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰åœ°åéƒ¨åˆ†ã£ã½ã„ã‚‚ã®ã‚’æŠ½å‡º
                                        let placeName = matchedKeyword;
                                        if (placeName === "é”ç£¨å±±") placeName = "ã ã‚‹ã¾å±±"; // èª­ã¿ã‚„ã™ãå¤‰æ›

                                        raceEvents.push(`ã€é€šéã€‘${r.name}é¸æ‰‹ãŒã€Œ${placeName}ã€ã‚’é€šéã—ã¾ã—ãŸï¼`);
                                    }
                                }
                            }
                        });
                        r.lastCheckpointIdx = currentIdx;
                    }
                }

                if (r.idx >= gpxPoints.length - 1) {
                    r.idx = gpxPoints.length - 1;
                    if (!r.finished) {
                        r.finished = true;
                        r.finishTime = document.getElementById('raceTimer').textContent;
                        raceEvents.push(`ã€ã‚´ãƒ¼ãƒ«ã€‘${r.name}é¸æ‰‹ãŒã‚´ãƒ¼ãƒ«ã—ã¾ã—ãŸï¼ã‚¿ã‚¤ãƒ : ${r.finishTime}`);
                    }
                }
            });

            if (!anyoneRunning) {
                isPlaying = false;
                updatePlayerUI();
                updateLeaderboard(); 
                showResultModal(); // å…¨å“¡ã‚´ãƒ¼ãƒ«ã—ãŸã‚‰ãƒªã‚¶ãƒ«ãƒˆè¡¨ç¤º
                return;
            }

            updatePlayerUI();
            checkAndShowComment();
            updateLeaderboard();

            animReqId = requestAnimationFrame(animLoop);
        }

        function updatePlayerUI() {
            runners.forEach(r => {
                const i = Math.floor(r.idx);
                const p = gpxPoints[i];
                if (p) {
                    r.marker.setLatLng([p.lat, p.lon]);
                    const opacity = r.state === 'stop' ? 0.5 : 1.0;
                    if (typeof r.marker.setOpacity === 'function') {
                        r.marker.setOpacity(opacity);
                    }
                }
            });

            const me = runners[0];
            const myP = gpxPoints[Math.floor(me.idx)];
            if (myP) {
                map.panTo([myP.lat, myP.lon], { animate: false }); 
                const percent = (me.idx / (gpxPoints.length - 1)) * 100;
                document.getElementById('progressSlider').value = percent;
                document.getElementById('currentDistDisplay').textContent = (myP.totalDist / 1000).toFixed(1) + "km";

                const chartMarker = document.getElementById('elevationMarker');
                if (chartMarker) {
                    const eleRange = maxEle - minEle;
                    const eleBottom = minEle - eleRange * 0.1;
                    const eleHeight = eleRange * 1.2;
                    const x = (myP.totalDist / routeTotalDistance) * 100;
                    const y = 100 - ((myP.ele - eleBottom) / eleHeight) * 100;
                    chartMarker.style.display = 'block';
                    chartMarker.setAttribute('cx', x + '%');
                    chartMarker.setAttribute('cy', y + '%');
                    document.getElementById('currentEleDisplay').textContent = Math.round(myP.ele) + "m";
                }
            }
        }

        function updateTimerDisplay() {
            const hours = Math.floor(elapsedTime / 3600);
            const minutes = Math.floor((elapsedTime % 3600) / 60);
            const seconds = Math.floor(elapsedTime % 60);
            const timeStr = 
                String(hours).padStart(2, '0') + ':' + 
                String(minutes).padStart(2, '0') + ':' + 
                String(seconds).padStart(2, '0');
            document.getElementById('raceTimer').textContent = timeStr;
        }

        function updateLeaderboard() {
            const sortedRunners = [...runners].sort((a, b) => {
                if (a.finished && b.finished) {
                    return a.finishTime.localeCompare(b.finishTime);
                }
                if (a.finished) return -1; 
                if (b.finished) return 1;
                return b.idx - a.idx;
            });
            
            // é †ä½å¤‰å‹•ãƒã‚§ãƒƒã‚¯ (è¿½ã„æŠœãæ¤œçŸ¥)
            sortedRunners.forEach((r, index) => {
                const currentRank = index;
                const prevRank = lastRankMap[r.id];
                if (prevRank !== undefined && currentRank < prevRank) {
                    // é †ä½ãŒä¸ŠãŒã£ãŸ
                    const overtaken = sortedRunners[currentRank + 1]; // æŠœã‹ã‚ŒãŸäººï¼ˆãŸã¶ã‚“ï¼‰
                    if (overtaken) {
                        raceEvents.push(`ã€è¿½ã„æŠœãã€‘${r.name}é¸æ‰‹ãŒ${overtaken.name}é¸æ‰‹ã‚’è¿½ã„æŠœãã¾ã—ãŸï¼`);
                    }
                }
                lastRankMap[r.id] = currentRank;
            });

            let html = '<div class="flex flex-col gap-1">';
            sortedRunners.forEach((r, i) => {
                let statusText = "";
                if (r.finished) {
                    statusText = `<span class="text-red-600 font-bold">Goal! ${r.finishTime}</span>`;
                } else {
                    const distKm = gpxPoints[Math.floor(r.idx)] ? (gpxPoints[Math.floor(r.idx)].totalDist / 1000).toFixed(1) : "0.0";
                    const stateIcon = r.state === 'stop' ? "â˜•" : "ğŸƒ";
                    statusText = `${distKm}km ${stateIcon}`;
                }
                const style = r.id === 0 ? "font-weight:bold; color:#2563eb;" : "color:#444;";
                html += `
                <div style="${style} display:flex; justify-content:space-between; align-items:center;">
                    <span>${i+1}. <span style="color:${r.color}">â—</span> ${r.name}</span>
                    <span style="font-size:10px; margin-left:8px;">${statusText}</span>
                </div>`;
            });
            html += '</div>';
            document.getElementById('leaderboardContent').innerHTML = html;
        }

        function checkAndShowComment() {
            const me = runners[0];
            const currentP = gpxPoints[Math.floor(me.idx)];
            if (!currentP) return;
            courseComments.forEach((c) => {
                const dist = map.distance([currentP.lat, currentP.lon], [c.lat, c.lon]);
                if (dist < 150) {
                    L.popup({ autoClose: true, closeOnClick: false, offset: [0, -10] })
                        .setLatLng([c.lat, c.lon]).setContent(c.text).openOn(map);
                }
            });
        }
    </script>
</body>
</html>